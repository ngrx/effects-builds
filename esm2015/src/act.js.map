{"version":3,"file":"act.js","sourceRoot":"ng://@ngrx/effects/","sources":["src/act.ts"],"names":[],"mappings":";;;;;AACA,OAAO,EACL,KAAK,EACL,KAAK,EACL,YAAY,EAGZ,OAAO,GACR,MAAM,MAAM,CAAC;AACd,OAAO,EACL,SAAS,EACT,aAAa,EACb,MAAM,EACN,QAAQ,EACR,GAAG,EACH,WAAW,GACZ,MAAM,gBAAgB,CAAC;;;;;;AAGxB,+BAyBC;;;IAjBC,4BAAmE;;IAInE,0BAAiD;;IAIjD,6BAA2D;;IAE3D,6BAE2C;;IAI3C,gCAAiE;;;;;;;;AAmCnE,MAAM,UAAU,GAAG;AAOjB,oEAAoE;AACpE,eAQ+D,EAC/D,OAAmD;UAM7C,EAAE,OAAO,EAAE,KAAK,EAAE,QAAQ,EAAE,QAAQ,EAAE,WAAW,EAAE,GACvD,OAAO,eAAe,KAAK,UAAU;QACnC,CAAC,CAAC;YACE,OAAO,EAAE,eAAe;YACxB,KAAK,EAAE,mBAAA,OAAO,EAAC;YACf,QAAQ,EAAE,SAAS;YACnB,QAAQ,EAAE,SAAS;YACnB,WAAW,EAAE,SAAS;SACvB;QACH,CAAC,iCAAM,eAAe,KAAE,QAAQ,EAAE,eAAe,CAAC,QAAQ,IAAI,SAAS,GAAE;IAO7E;;;;IAAO,MAAM,CAAC,EAAE,CACd,KAAK;;;IACH,GAA6B,EAAE;;cACvB,OAAO,GAAG,IAAI,OAAO,EAAqB;QAChD,OAAO,KAAK,CACV,MAAM,CAAC,IAAI,CACT,QAAQ;;;;;QAAC,CAAC,KAAK,EAAE,KAAK,EAAE,EAAE,CACxB,KAAK;;;QAAC,GAAG,EAAE;;gBACL,SAAS,GAAG,KAAK;;gBACjB,OAAO,GAAG,KAAK;;gBACf,cAAc,GAAG,CAAC;YACtB,OAAO,OAAO,CAAC,KAAK,EAAE,KAAK,CAAC,CAAC,IAAI,CAC/B,WAAW,EAAE,EACb,GAAG;;;;YACD,CAAC,YAAY,EAA0C,EAAE;gBACvD,QAAQ,YAAY,CAAC,IAAI,EAAE;oBACzB,KAAK,GAAG;wBACN,OAAO,GAAG,IAAI,CAAC;wBACf,OAAO,IAAI,YAAY,CAErB;wBADA,+BAA+B;wBAC/B,GAAG,EAAO,EACV,KAAK,CAAC,YAAY,CAAC,KAAK,EAAE,KAAK,CAAC,CACjC,CAAC;oBACJ,KAAK,GAAG;wBACN,SAAS,GAAG,IAAI,CAAC;wBACjB,OAAO,QAAQ;4BACb,CAAC,CAAC,IAAI,YAAY,CAEd;4BADA,+BAA+B;4BAC/B,GAAG,EAAO,EACV,QAAQ,CAAC,cAAc,EAAE,KAAK,CAAC,CAChC;4BACH,CAAC,CAAC,SAAS,CAAC;oBAChB;wBACE,EAAE,cAAc,CAAC;wBACjB,OAAO,YAAY,CAAC;iBACvB;YACH,CAAC,EACF,EACD,MAAM;;;;YAAC,CAAC,CAAC,EAA8B,EAAE,CAAC,CAAC,IAAI,IAAI,EAAC,EACpD,aAAa,EAAE,EACf,QAAQ;;;YAAC,GAAG,EAAE;gBACZ,IAAI,CAAC,SAAS,IAAI,CAAC,OAAO,IAAI,WAAW,EAAE;oBACzC,OAAO,CAAC,IAAI,CAAC,WAAW,CAAC,cAAc,EAAE,KAAK,CAAC,CAAC,CAAC;iBAClD;YACH,CAAC,EAAC,CACH,CAAC;QACJ,CAAC,EAAC,EACH,CACF,EACD,OAAO,CACR,CAAC;IACJ,CAAC,EACF,EAAC;AACN,CAAC","sourcesContent":["import { Action } from '@ngrx/store';\nimport {\n  defer,\n  merge,\n  Notification,\n  Observable,\n  OperatorFunction,\n  Subject,\n} from 'rxjs';\nimport {\n  concatMap,\n  dematerialize,\n  filter,\n  finalize,\n  map,\n  materialize,\n} from 'rxjs/operators';\n\n/** Represents config with named paratemeters for act */\nexport interface ActConfig<\n  Input,\n  OutputAction extends Action,\n  ErrorAction extends Action,\n  CompleteAction extends Action,\n  UnsubscribeAction extends Action\n> {\n  // Project function that produces the output actions in success cases\n  project: (input: Input, index: number) => Observable<OutputAction>;\n  // Error handle function for project\n  // error that happened during project execution\n  // input value that project errored with\n  error: (error: any, input: Input) => ErrorAction;\n  // Optional complete action provider\n  // count is the number of actions project emitted before completion\n  // input value that project completed with\n  complete?: (count: number, input: Input) => CompleteAction;\n  // Optional flattening operator\n  operator?: <Input, OutputAction>(\n    project: (input: Input, index: number) => Observable<OutputAction>\n  ) => OperatorFunction<Input, OutputAction>;\n  // Optional unsubscribe action provider\n  // count is the number of actions project emitted before unsubscribing\n  // input value that was unsubscribed from\n  unsubscribe?: (count: number, input: Input) => UnsubscribeAction;\n}\n\n/**\n * Wraps project fn with error handling making it safe to use in Effects.\n * Takes either config with named properties that represent different possible\n * callbacks or project/error callbacks that are required.\n */\nexport function act<\n  Input,\n  OutputAction extends Action,\n  ErrorAction extends Action\n>(\n  project: (input: Input, index: number) => Observable<OutputAction>,\n  error: (error: any, input: Input) => ErrorAction\n): (source: Observable<Input>) => Observable<OutputAction | ErrorAction>;\nexport function act<\n  Input,\n  OutputAction extends Action,\n  ErrorAction extends Action,\n  CompleteAction extends Action = never,\n  UnsubscribeAction extends Action = never\n>(\n  config: ActConfig<\n    Input,\n    OutputAction,\n    ErrorAction,\n    CompleteAction,\n    UnsubscribeAction\n  >\n): (\n  source: Observable<Input>\n) => Observable<\n  OutputAction | ErrorAction | CompleteAction | UnsubscribeAction\n>;\nexport function act<\n  Input,\n  OutputAction extends Action,\n  ErrorAction extends Action,\n  CompleteAction extends Action = never,\n  UnsubscribeAction extends Action = never\n>(\n  /** Allow to take either config object or project/error functions */\n  configOrProject:\n    | ActConfig<\n        Input,\n        OutputAction,\n        ErrorAction,\n        CompleteAction,\n        UnsubscribeAction\n      >\n    | ((input: Input, index: number) => Observable<OutputAction>),\n  errorFn?: (error: any, input: Input) => ErrorAction\n): (\n  source: Observable<Input>\n) => Observable<\n  OutputAction | ErrorAction | CompleteAction | UnsubscribeAction\n> {\n  const { project, error, complete, operator, unsubscribe } =\n    typeof configOrProject === 'function'\n      ? {\n          project: configOrProject,\n          error: errorFn!,\n          operator: concatMap,\n          complete: undefined,\n          unsubscribe: undefined,\n        }\n      : { ...configOrProject, operator: configOrProject.operator || concatMap };\n\n  type ResultAction =\n    | OutputAction\n    | ErrorAction\n    | CompleteAction\n    | UnsubscribeAction;\n  return source =>\n    defer(\n      (): Observable<ResultAction> => {\n        const subject = new Subject<UnsubscribeAction>();\n        return merge(\n          source.pipe(\n            operator((input, index) =>\n              defer(() => {\n                let completed = false;\n                let errored = false;\n                let projectedCount = 0;\n                return project(input, index).pipe(\n                  materialize(),\n                  map(\n                    (notification): Notification<ResultAction> | undefined => {\n                      switch (notification.kind) {\n                        case 'E':\n                          errored = true;\n                          return new Notification(\n                            // TODO: remove any in RxJS 6.5\n                            'N' as any,\n                            error(notification.error, input)\n                          );\n                        case 'C':\n                          completed = true;\n                          return complete\n                            ? new Notification(\n                                // TODO: remove any in RxJS 6.5\n                                'N' as any,\n                                complete(projectedCount, input)\n                              )\n                            : undefined;\n                        default:\n                          ++projectedCount;\n                          return notification;\n                      }\n                    }\n                  ),\n                  filter((n): n is NonNullable<typeof n> => n != null),\n                  dematerialize(),\n                  finalize(() => {\n                    if (!completed && !errored && unsubscribe) {\n                      subject.next(unsubscribe(projectedCount, input));\n                    }\n                  })\n                );\n              })\n            )\n          ),\n          subject\n        );\n      }\n    );\n}\n"]}