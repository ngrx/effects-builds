{"version":3,"file":"effects_resolver.js","sourceRoot":"ng://@ngrx/effects/","sources":["src/effects_resolver.ts"],"names":[],"mappings":";;;;;AACA,OAAO,EAAE,KAAK,EAA4B,MAAM,MAAM,CAAC;AACvD,OAAO,EAAE,cAAc,EAAE,GAAG,EAAE,WAAW,EAAE,MAAM,gBAAgB,CAAC;AAGlE,OAAO,EAAE,iBAAiB,EAAE,MAAM,oBAAoB,CAAC;AAEvD,OAAO,EAAE,oBAAoB,EAAE,MAAM,SAAS,CAAC;;;;;;;AAG/C,MAAM,UAAU,YAAY,CAC1B,cAAmB,EACnB,kBAAgC,EAChC,mBAAwC;;UAElC,UAAU,GAAG,oBAAoB,CAAC,cAAc,CAAC,CAAC,WAAW,CAAC,IAAI;;UAElE,YAAY,GAAsB,iBAAiB,CAAC,cAAc,CAAC,CAAC,GAAG;;;;IAC3E,CAAC,EACC,YAAY,EACZ,QAAQ,EACR,sBAAsB,GACvB,EAAkC,EAAE;;cAC7B,WAAW,GACf,OAAO,cAAc,CAAC,YAAY,CAAC,KAAK,UAAU;YAChD,CAAC,CAAC,cAAc,CAAC,YAAY,CAAC,EAAE;YAChC,CAAC,CAAC,cAAc,CAAC,YAAY,CAAC;;cAE5B,aAAa,GAAG,sBAAsB;YAC1C,CAAC,CAAC,mBAAmB,CAAC,WAAW,EAAE,kBAAkB,CAAC;YACtD,CAAC,CAAC,WAAW;QAEf,IAAI,QAAQ,KAAK,KAAK,EAAE;YACtB,OAAO,aAAa,CAAC,IAAI,CAAC,cAAc,EAAE,CAAC,CAAC;SAC7C;;cAEK,aAAa,GAAG,aAAa,CAAC,IAAI,CAAC,WAAW,EAAE,CAAC;QAEvD,OAAO,aAAa,CAAC,IAAI,CACvB,GAAG;;;;QACD,CAAC,YAAkC,EAAsB,EAAE,CAAC,CAAC;YAC3D,MAAM,EAAE,cAAc,CAAC,YAAY,CAAC;YACpC,YAAY;YACZ,YAAY;YACZ,UAAU;YACV,cAAc;SACf,CAAC,EACH,CACF,CAAC;IACJ,CAAC,EACF;IAED,OAAO,KAAK,CAAC,GAAG,YAAY,CAAC,CAAC;AAChC,CAAC","sourcesContent":["import { Action } from '@ngrx/store';\nimport { merge, Notification, Observable } from 'rxjs';\nimport { ignoreElements, map, materialize } from 'rxjs/operators';\n\nimport { EffectNotification } from './effect_notification';\nimport { getSourceMetadata } from './effects_metadata';\nimport { EffectsErrorHandler } from './effects_error_handler';\nimport { getSourceForInstance } from './utils';\nimport { ErrorHandler } from '@angular/core';\n\nexport function mergeEffects(\n  sourceInstance: any,\n  globalErrorHandler: ErrorHandler,\n  effectsErrorHandler: EffectsErrorHandler\n): Observable<EffectNotification> {\n  const sourceName = getSourceForInstance(sourceInstance).constructor.name;\n\n  const observables$: Observable<any>[] = getSourceMetadata(sourceInstance).map(\n    ({\n      propertyName,\n      dispatch,\n      useEffectsErrorHandler,\n    }): Observable<EffectNotification> => {\n      const observable$: Observable<any> =\n        typeof sourceInstance[propertyName] === 'function'\n          ? sourceInstance[propertyName]()\n          : sourceInstance[propertyName];\n\n      const effectAction$ = useEffectsErrorHandler\n        ? effectsErrorHandler(observable$, globalErrorHandler)\n        : observable$;\n\n      if (dispatch === false) {\n        return effectAction$.pipe(ignoreElements());\n      }\n\n      const materialized$ = effectAction$.pipe(materialize());\n\n      return materialized$.pipe(\n        map(\n          (notification: Notification<Action>): EffectNotification => ({\n            effect: sourceInstance[propertyName],\n            notification,\n            propertyName,\n            sourceName,\n            sourceInstance,\n          })\n        )\n      );\n    }\n  );\n\n  return merge(...observables$);\n}\n"]}