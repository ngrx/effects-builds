{
  "version": 3,
  "sources": ["../../../../modules/effects/src/models.ts", "../../../../modules/effects/src/effect_creator.ts", "../../../../modules/effects/src/effects_metadata.ts", "../../../../modules/effects/src/utils.ts", "../../../../modules/effects/src/effects_resolver.ts", "../../../../modules/effects/src/effects_error_handler.ts", "../../../../modules/effects/src/actions.ts", "../../../../modules/effects/src/tokens.ts", "../../../../modules/effects/src/effects_actions.ts", "../../../../modules/effects/src/effect_notification.ts", "../../../../modules/effects/src/lifecycle_hooks.ts", "../../../../modules/effects/src/effect_sources.ts", "../../../../modules/effects/src/effects_runner.ts", "../../../../modules/effects/src/effects_root_module.ts", "../../../../modules/effects/src/effects_feature_module.ts", "../../../../modules/effects/src/effects_module.ts", "../../../../modules/effects/src/act.ts", "../../../../modules/effects/src/provide_effects.ts", "../../../../modules/effects/src/index.ts"],
  "sourcesContent": ["import { Observable } from 'rxjs';\n\n/**\n * Configures an effect created by `createEffect`.\n */\nexport interface EffectConfig {\n  /**\n   * Determines if the action emitted by the effect is dispatched to the store.\n   * If false, effect does not need to return type `Observable<Action>`.\n   */\n  dispatch?: boolean;\n  /**\n   * Determines whether the functional effect will be created.\n   * If true, the effect can be created outside the effects class.\n   */\n  functional?: boolean;\n  /**\n   * Determines if the effect will be resubscribed to if an error occurs in the main actions stream.\n   */\n  useEffectsErrorHandler?: boolean;\n}\n\nexport const DEFAULT_EFFECT_CONFIG: Readonly<Required<EffectConfig>> = {\n  dispatch: true,\n  functional: false,\n  useEffectsErrorHandler: true,\n};\n\nexport const CREATE_EFFECT_METADATA_KEY = '__@ngrx/effects_create__';\n\nexport interface CreateEffectMetadata {\n  [CREATE_EFFECT_METADATA_KEY]: EffectConfig;\n}\n\nexport interface FunctionalCreateEffectMetadata extends CreateEffectMetadata {\n  [CREATE_EFFECT_METADATA_KEY]: EffectConfig & { functional: true };\n}\n\nexport type FunctionalEffect<\n  Source extends () => Observable<unknown> = () => Observable<unknown>\n> = Source & FunctionalCreateEffectMetadata;\n\nexport type EffectPropertyKey<T extends Record<keyof T, Object>> = Exclude<\n  keyof T,\n  keyof Object\n>;\n\nexport interface EffectMetadata<T extends Record<keyof T, Object>>\n  extends Required<EffectConfig> {\n  propertyName: EffectPropertyKey<T>;\n}\n\nexport type EffectsMetadata<T extends Record<keyof T, Object>> = {\n  [Key in EffectPropertyKey<T>]?: EffectConfig;\n};\n", "import { Observable } from 'rxjs';\nimport { Action, ActionCreator } from '@ngrx/store';\nimport {\n  CREATE_EFFECT_METADATA_KEY,\n  CreateEffectMetadata,\n  DEFAULT_EFFECT_CONFIG,\n  EffectConfig,\n  EffectMetadata,\n  FunctionalEffect,\n} from './models';\n\ntype DispatchType<T> = T extends { dispatch: infer U } ? U : true;\ntype ObservableType<T, OriginalType> = T extends false ? OriginalType : Action;\ntype EffectResult<OT> = Observable<OT> | ((...args: any[]) => Observable<OT>);\ntype ConditionallyDisallowActionCreator<DT, Result> = DT extends false\n  ? unknown // If DT (DispatchType is false, then we don't enforce any return types)\n  : Result extends EffectResult<infer OT>\n  ? OT extends ActionCreator\n    ? 'ActionCreator cannot be dispatched. Did you forget to call the action creator function?'\n    : unknown\n  : unknown;\n\nexport function createEffect<\n  C extends EffectConfig & { functional?: false },\n  DT extends DispatchType<C>,\n  OTP,\n  R extends EffectResult<OT>,\n  OT extends ObservableType<DT, OTP>\n>(\n  source: () => R & ConditionallyDisallowActionCreator<DT, R>,\n  config?: C\n): R & CreateEffectMetadata;\nexport function createEffect<Source extends () => Observable<unknown>>(\n  source: Source,\n  config: EffectConfig & { functional: true; dispatch: false }\n): FunctionalEffect<Source>;\nexport function createEffect<Source extends () => Observable<Action>>(\n  source: Source & ConditionallyDisallowActionCreator<true, ReturnType<Source>>,\n  config: EffectConfig & { functional: true; dispatch?: true }\n): FunctionalEffect<Source>;\n/**\n * @description\n *\n * Creates an effect from a source and an `EffectConfig`.\n *\n * @param source A function which returns an observable or observable factory.\n * @param config A `EffectConfig` to configure the effect. By default,\n * `dispatch` is true, `functional` is false, and `useEffectsErrorHandler` is\n * true.\n * @returns If `EffectConfig`#`functional` is true, returns the source function.\n * Else, returns the source function result. When `EffectConfig`#`dispatch` is\n * true, the source function result needs to be `Observable<Action>`.\n *\n * @usageNotes\n *\n * ### Class Effects\n *\n * ```ts\n * @Injectable()\n * export class FeatureEffects {\n *   // mapping to a different action\n *   readonly effect1$ = createEffect(\n *     () => this.actions$.pipe(\n *       ofType(FeatureActions.actionOne),\n *       map(() => FeatureActions.actionTwo())\n *     )\n *   );\n *\n *   // non-dispatching effect\n *   readonly effect2$ = createEffect(\n *     () => this.actions$.pipe(\n *       ofType(FeatureActions.actionTwo),\n *       tap(() => console.log('Action Two Dispatched'))\n *     ),\n *     { dispatch: false } // FeatureActions.actionTwo is not dispatched\n *   );\n *\n *   constructor(private readonly actions$: Actions) {}\n * }\n * ```\n *\n * ### Functional Effects\n *\n * ```ts\n * // mapping to a different action\n * export const loadUsers = createEffect(\n *   (actions$ = inject(Actions), usersService = inject(UsersService)) => {\n *     return actions$.pipe(\n *       ofType(UsersPageActions.opened),\n *       exhaustMap(() => {\n *         return usersService.getAll().pipe(\n *           map((users) => UsersApiActions.usersLoadedSuccess({ users })),\n *           catchError((error) =>\n *             of(UsersApiActions.usersLoadedFailure({ error }))\n *           )\n *         );\n *       })\n *     );\n *   },\n *   { functional: true }\n * );\n *\n * // non-dispatching functional effect\n * export const logDispatchedActions = createEffect(\n *   () => inject(Actions).pipe(tap(console.log)),\n *   { functional: true, dispatch: false }\n * );\n * ```\n */\nexport function createEffect<\n  Result extends EffectResult<unknown>,\n  Source extends () => Result\n>(\n  source: Source,\n  config: EffectConfig = {}\n): (Source | Result) & CreateEffectMetadata {\n  const effect = config.functional ? source : source();\n  const value: EffectConfig = {\n    ...DEFAULT_EFFECT_CONFIG,\n    ...config, // Overrides any defaults if values are provided\n  };\n  Object.defineProperty(effect, CREATE_EFFECT_METADATA_KEY, {\n    value,\n  });\n  return effect as typeof effect & CreateEffectMetadata;\n}\n\nexport function getCreateEffectMetadata<T extends Record<keyof T, Object>>(\n  instance: T\n): EffectMetadata<T>[] {\n  const propertyNames = Object.getOwnPropertyNames(instance) as Array<keyof T>;\n\n  const metadata: EffectMetadata<T>[] = propertyNames\n    .filter((propertyName) => {\n      if (\n        instance[propertyName] &&\n        instance[propertyName].hasOwnProperty(CREATE_EFFECT_METADATA_KEY)\n      ) {\n        // If the property type has overridden `hasOwnProperty` we need to ensure\n        // that the metadata is valid (containing a `dispatch` property)\n        // https://github.com/ngrx/platform/issues/2975\n        const property = instance[propertyName] as any;\n        return property[CREATE_EFFECT_METADATA_KEY].hasOwnProperty('dispatch');\n      }\n      return false;\n    })\n    .map((propertyName) => {\n      const metaData = (instance[propertyName] as any)[\n        CREATE_EFFECT_METADATA_KEY\n      ];\n      return {\n        propertyName,\n        ...metaData,\n      };\n    });\n\n  return metadata;\n}\n", "import { EffectMetadata, EffectsMetadata } from './models';\nimport { getCreateEffectMetadata } from './effect_creator';\n\nexport function getEffectsMetadata<T extends Record<keyof T, Object>>(\n  instance: T\n): EffectsMetadata<T> {\n  return getSourceMetadata(instance).reduce(\n    (\n      acc: EffectsMetadata<T>,\n      { propertyName, dispatch, useEffectsErrorHandler }\n    ) => {\n      acc[propertyName] = { dispatch, useEffectsErrorHandler };\n      return acc;\n    },\n    {}\n  );\n}\n\nexport function getSourceMetadata<T extends { [props in keyof T]: object }>(\n  instance: T\n): EffectMetadata<T>[] {\n  return getCreateEffectMetadata(instance);\n}\n", "import { InjectionToken, Type } from '@angular/core';\n\nexport function getSourceForInstance<T>(instance: T): T {\n  return Object.getPrototypeOf(instance);\n}\n\nexport function isClassInstance(obj: object): boolean {\n  return (\n    !!obj.constructor &&\n    obj.constructor.name !== 'Object' &&\n    obj.constructor.name !== 'Function'\n  );\n}\n\nexport function isClass(\n  classOrRecord: Type<unknown> | Record<string, unknown>\n): classOrRecord is Type<unknown> {\n  return typeof classOrRecord === 'function';\n}\n\nexport function getClasses(\n  classesAndRecords: Array<Type<unknown> | Record<string, unknown>>\n): Type<unknown>[] {\n  return classesAndRecords.filter(isClass);\n}\n\nexport function isToken(\n  tokenOrRecord:\n    | Type<unknown>\n    | InjectionToken<unknown>\n    | Record<string, unknown>\n): tokenOrRecord is Type<unknown> | InjectionToken<unknown> {\n  return tokenOrRecord instanceof InjectionToken || isClass(tokenOrRecord);\n}\n\n// TODO: replace with RxJS interfaces when possible\n// needs dependency on RxJS >=7\nexport interface NextNotification<T> {\n  kind: 'N';\n  value: T;\n}\n\nexport interface ErrorNotification {\n  kind: 'E';\n  error: any;\n}\n\nexport interface CompleteNotification {\n  kind: 'C';\n}\n\nexport type ObservableNotification<T> =\n  | NextNotification<T>\n  | ErrorNotification\n  | CompleteNotification;\n", "import { Action } from '@ngrx/store';\nimport { merge, Observable } from 'rxjs';\nimport { ignoreElements, map, materialize } from 'rxjs/operators';\n\nimport { EffectNotification } from './effect_notification';\nimport { getSourceMetadata } from './effects_metadata';\nimport { EffectsErrorHandler } from './effects_error_handler';\nimport { getSourceForInstance } from './utils';\nimport { ErrorHandler } from '@angular/core';\n\nexport function mergeEffects(\n  sourceInstance: any,\n  globalErrorHandler: ErrorHandler,\n  effectsErrorHandler: EffectsErrorHandler\n): Observable<EffectNotification> {\n  const source = getSourceForInstance(sourceInstance);\n  const isClassBasedEffect = !!source && source.constructor.name !== 'Object';\n  const sourceName = isClassBasedEffect ? source.constructor.name : null;\n\n  const observables$: Observable<any>[] = getSourceMetadata(sourceInstance).map(\n    ({\n      propertyName,\n      dispatch,\n      useEffectsErrorHandler,\n    }): Observable<EffectNotification> => {\n      const observable$: Observable<any> =\n        typeof sourceInstance[propertyName] === 'function'\n          ? sourceInstance[propertyName]()\n          : sourceInstance[propertyName];\n\n      const effectAction$ = useEffectsErrorHandler\n        ? effectsErrorHandler(observable$, globalErrorHandler)\n        : observable$;\n\n      if (dispatch === false) {\n        return effectAction$.pipe(ignoreElements());\n      }\n\n      const materialized$ = effectAction$.pipe(materialize<Action>());\n\n      return materialized$.pipe(\n        map(\n          (notification): EffectNotification => ({\n            effect: sourceInstance[propertyName],\n            notification,\n            propertyName,\n            sourceName,\n            sourceInstance,\n          })\n        )\n      );\n    }\n  );\n\n  return merge(...observables$);\n}\n", "import { ErrorHandler } from '@angular/core';\nimport { Action } from '@ngrx/store';\nimport { Observable } from 'rxjs';\nimport { catchError } from 'rxjs/operators';\n\nexport type EffectsErrorHandler = <T extends Action>(\n  observable$: Observable<T>,\n  errorHandler: ErrorHandler\n) => Observable<T>;\n\nconst MAX_NUMBER_OF_RETRY_ATTEMPTS = 10;\n\nexport function defaultEffectsErrorHandler<T extends Action>(\n  observable$: Observable<T>,\n  errorHandler: ErrorHandler,\n  retryAttemptLeft: number = MAX_NUMBER_OF_RETRY_ATTEMPTS\n): Observable<T> {\n  return observable$.pipe(\n    catchError((error) => {\n      if (errorHandler) errorHandler.handleError(error);\n      if (retryAttemptLeft <= 1) {\n        return observable$; // last attempt\n      }\n      // Return observable that produces this particular effect\n      return defaultEffectsErrorHandler(\n        observable$,\n        errorHandler,\n        retryAttemptLeft - 1\n      );\n    })\n  );\n}\n", "import { Inject, Injectable } from '@angular/core';\nimport {\n  Action,\n  ActionCreator,\n  Creator,\n  ScannedActionsSubject,\n} from '@ngrx/store';\nimport { Observable, OperatorFunction, Operator } from 'rxjs';\nimport { filter } from 'rxjs/operators';\n\n@Injectable({ providedIn: 'root' })\nexport class Actions<V = Action> extends Observable<V> {\n  constructor(@Inject(ScannedActionsSubject) source?: Observable<V>) {\n    super();\n\n    if (source) {\n      this.source = source;\n    }\n  }\n\n  override lift<R>(operator: Operator<V, R>): Observable<R> {\n    const observable = new Actions<R>();\n    observable.source = this;\n    observable.operator = operator;\n    return observable;\n  }\n}\n\n// Module-private helper type\ntype ActionExtractor<\n  T extends string | AC,\n  AC extends ActionCreator<string, Creator>,\n  E\n> = T extends string ? E : ReturnType<Extract<T, AC>>;\n\nexport function ofType<\n  AC extends ActionCreator<string, Creator>[],\n  U extends Action = Action,\n  V = ReturnType<AC[number]>\n>(...allowedTypes: AC): OperatorFunction<U, V>;\n\nexport function ofType<\n  E extends Extract<U, { type: T1 }>,\n  AC extends ActionCreator<string, Creator>,\n  T1 extends string | AC,\n  U extends Action = Action,\n  V = T1 extends string ? E : ReturnType<Extract<T1, AC>>\n>(t1: T1): OperatorFunction<U, V>;\nexport function ofType<\n  E extends Extract<U, { type: T1 | T2 }>,\n  AC extends ActionCreator<string, Creator>,\n  T1 extends string | AC,\n  T2 extends string | AC,\n  U extends Action = Action,\n  V = ActionExtractor<T1 | T2, AC, E>\n>(t1: T1, t2: T2): OperatorFunction<U, V>;\nexport function ofType<\n  E extends Extract<U, { type: T1 | T2 | T3 }>,\n  AC extends ActionCreator<string, Creator>,\n  T1 extends string | AC,\n  T2 extends string | AC,\n  T3 extends string | AC,\n  U extends Action = Action,\n  V = ActionExtractor<T1 | T2 | T3, AC, E>\n>(t1: T1, t2: T2, t3: T3): OperatorFunction<U, V>;\nexport function ofType<\n  E extends Extract<U, { type: T1 | T2 | T3 | T4 }>,\n  AC extends ActionCreator<string, Creator>,\n  T1 extends string | AC,\n  T2 extends string | AC,\n  T3 extends string | AC,\n  T4 extends string | AC,\n  U extends Action = Action,\n  V = ActionExtractor<T1 | T2 | T3 | T4, AC, E>\n>(t1: T1, t2: T2, t3: T3, t4: T4): OperatorFunction<U, V>;\nexport function ofType<\n  E extends Extract<U, { type: T1 | T2 | T3 | T4 | T5 }>,\n  AC extends ActionCreator<string, Creator>,\n  T1 extends string | AC,\n  T2 extends string | AC,\n  T3 extends string | AC,\n  T4 extends string | AC,\n  T5 extends string | AC,\n  U extends Action = Action,\n  V = ActionExtractor<T1 | T2 | T3 | T4 | T5, AC, E>\n>(t1: T1, t2: T2, t3: T3, t4: T4, t5: T5): OperatorFunction<U, V>;\n/**\n * Fallback for more than 5 arguments.\n * There is no inference, so the return type is the same as the input -\n * Observable<Action>.\n *\n * We provide a type parameter, even though TS will not infer it from the\n * arguments, to preserve backwards compatibility with old versions of ngrx.\n */\nexport function ofType<V extends Action>(\n  ...allowedTypes: Array<string | ActionCreator<string, Creator>>\n): OperatorFunction<Action, V>;\n/**\n * `ofType` filters an Observable of `Actions` into an Observable of the actions\n * whose type strings are passed to it.\n *\n * For example, if `actions` has type `Actions<AdditionAction|SubstractionAction>`, and\n * the type of the `Addition` action is `add`, then\n * `actions.pipe(ofType('add'))` returns an `Observable<AdditionAction>`.\n *\n * Properly typing this function is hard and requires some advanced TS tricks\n * below.\n *\n * Type narrowing automatically works, as long as your `actions` object\n * starts with a `Actions<SomeUnionOfActions>` instead of generic `Actions`.\n *\n * For backwards compatibility, when one passes a single type argument\n * `ofType<T>('something')` the result is an `Observable<T>`. Note, that `T`\n * completely overrides any possible inference from 'something'.\n *\n * Unfortunately, for unknown 'actions: Actions' these types will produce\n * 'Observable<never>'. In such cases one has to manually set the generic type\n * like `actions.ofType<AdditionAction>('add')`.\n *\n * @usageNotes\n *\n * Filter the Actions stream on the \"customers page loaded\" action\n *\n * ```ts\n * import { ofType } from '@ngrx/effects';\n * import * fromCustomers from '../customers';\n *\n * this.actions$.pipe(\n *  ofType(fromCustomers.pageLoaded)\n * )\n * ```\n */\nexport function ofType(\n  ...allowedTypes: Array<string | ActionCreator<string, Creator>>\n): OperatorFunction<Action, Action> {\n  return filter((action: Action) =>\n    allowedTypes.some((typeOrActionCreator) => {\n      if (typeof typeOrActionCreator === 'string') {\n        // Comparing the string to type\n        return typeOrActionCreator === action.type;\n      }\n\n      // We are filtering by ActionCreator\n      return typeOrActionCreator.type === action.type;\n    })\n  );\n}\n", "import { InjectionToken, Type } from '@angular/core';\nimport {\n  defaultEffectsErrorHandler,\n  EffectsErrorHandler,\n} from './effects_error_handler';\nimport { FunctionalEffect } from './models';\n\nexport const _ROOT_EFFECTS_GUARD = new InjectionToken<void>(\n  '@ngrx/effects Internal Root Guard'\n);\nexport const USER_PROVIDED_EFFECTS = new InjectionToken<\n  Array<Type<unknown> | InjectionToken<unknown>>[]\n>('@ngrx/effects User Provided Effects');\nexport const _ROOT_EFFECTS = new InjectionToken<\n  [Array<Type<unknown> | Record<string, FunctionalEffect>>]\n>('@ngrx/effects Internal Root Effects');\nexport const _ROOT_EFFECTS_INSTANCES = new InjectionToken<unknown[]>(\n  '@ngrx/effects Internal Root Effects Instances'\n);\nexport const _FEATURE_EFFECTS = new InjectionToken<\n  Array<Type<unknown> | Record<string, FunctionalEffect>>[]\n>('@ngrx/effects Internal Feature Effects');\nexport const _FEATURE_EFFECTS_INSTANCE_GROUPS = new InjectionToken<unknown[][]>(\n  '@ngrx/effects Internal Feature Effects Instance Groups'\n);\nexport const EFFECTS_ERROR_HANDLER = new InjectionToken<EffectsErrorHandler>(\n  '@ngrx/effects Effects Error Handler',\n  { providedIn: 'root', factory: () => defaultEffectsErrorHandler }\n);\n", "import { createAction } from '@ngrx/store';\n\nexport const ROOT_EFFECTS_INIT = '@ngrx/effects/init';\nexport const rootEffectsInit = createAction(ROOT_EFFECTS_INIT);\n", "import { ErrorHandler } from '@angular/core';\nimport { Action } from '@ngrx/store';\nimport { Observable } from 'rxjs';\nimport { ObservableNotification } from './utils';\n\nexport interface EffectNotification {\n  effect: Observable<any> | (() => Observable<any>);\n  propertyName: PropertyKey;\n  sourceName: string | null;\n  sourceInstance: any;\n  notification: ObservableNotification<Action | null | undefined>;\n}\n\nexport function reportInvalidActions(\n  output: EffectNotification,\n  reporter: ErrorHandler\n) {\n  if (output.notification.kind === 'N') {\n    const action = output.notification.value;\n    const isInvalidAction = !isAction(action);\n\n    if (isInvalidAction) {\n      reporter.handleError(\n        new Error(\n          `Effect ${getEffectName(\n            output\n          )} dispatched an invalid action: ${stringify(action)}`\n        )\n      );\n    }\n  }\n}\n\nfunction isAction(action: any): action is Action {\n  return (\n    typeof action !== 'function' &&\n    action &&\n    action.type &&\n    typeof action.type === 'string'\n  );\n}\n\nfunction getEffectName({\n  propertyName,\n  sourceInstance,\n  sourceName,\n}: EffectNotification) {\n  const isMethod = typeof sourceInstance[propertyName] === 'function';\n  const isClassBasedEffect = !!sourceName;\n\n  return isClassBasedEffect\n    ? `\"${sourceName}.${String(propertyName)}${isMethod ? '()' : ''}\"`\n    : `\"${String(propertyName)}()\"`;\n}\n\nfunction stringify(action: Action | null | undefined) {\n  try {\n    return JSON.stringify(action);\n  } catch {\n    return action;\n  }\n}\n", "import { Observable } from 'rxjs';\nimport { EffectNotification } from '.';\nimport { Action } from '@ngrx/store';\n\n/**\n * @description\n * Interface to set an identifier for effect instances.\n *\n * By default, each Effects class is registered\n * once regardless of how many times the Effect class\n * is loaded. By implementing this interface, you define\n * a unique identifier to register an Effects class instance\n * multiple times.\n *\n * @usageNotes\n *\n * ### Set an identifier for an Effects class\n *\n * ```ts\n * class EffectWithIdentifier implements OnIdentifyEffects {\n *  constructor(private effectIdentifier: string) {}\n *\n *  ngrxOnIdentifyEffects() {\n *    return this.effectIdentifier;\n *  }\n *\n * ```\n */\nexport declare interface OnIdentifyEffects {\n  /**\n   * @description\n   * String identifier to differentiate effect instances.\n   */\n  ngrxOnIdentifyEffects(): string;\n}\n\nexport const onIdentifyEffectsKey: keyof OnIdentifyEffects =\n  'ngrxOnIdentifyEffects';\n\nexport function isOnIdentifyEffects(\n  instance: any\n): instance is OnIdentifyEffects {\n  return isFunction(instance, onIdentifyEffectsKey);\n}\n\n/**\n * @description\n * Interface to control the lifecycle of effects.\n *\n * By default, effects are merged and subscribed to the store. Implement the OnRunEffects interface to control the lifecycle of the resolved effects.\n *\n * @usageNotes\n *\n * ### Implement the OnRunEffects interface on an Effects class\n *\n * ```ts\n * export class UserEffects implements OnRunEffects {\n *   constructor(private actions$: Actions) {}\n *\n *   ngrxOnRunEffects(resolvedEffects$: Observable<EffectNotification>) {\n *     return this.actions$.pipe(\n *       ofType('LOGGED_IN'),\n *       exhaustMap(() =>\n *         resolvedEffects$.pipe(\n *           takeUntil(this.actions$.pipe(ofType('LOGGED_OUT')))\n *         )\n *       )\n *     );\n *   }\n * }\n * ```\n */\nexport declare interface OnRunEffects {\n  /**\n   * @description\n   * Method to control the lifecycle of effects.\n   */\n  ngrxOnRunEffects(\n    resolvedEffects$: Observable<EffectNotification>\n  ): Observable<EffectNotification>;\n}\n\nexport const onRunEffectsKey: keyof OnRunEffects = 'ngrxOnRunEffects';\n\nexport function isOnRunEffects(instance: any): instance is OnRunEffects {\n  return isFunction(instance, onRunEffectsKey);\n}\n\n/**\n * @description\n * Interface to dispatch an action after effect registration.\n *\n * Implement this interface to dispatch a custom action after\n * the effect has been added. You can listen to this action\n * in the rest of the application to execute something after\n * the effect is registered.\n *\n * @usageNotes\n *\n * ### Set an identifier for an Effects class\n *\n * ```ts\n * class EffectWithInitAction implements OnInitEffects {\n *  ngrxOnInitEffects() {\n *    return { type: '[EffectWithInitAction] Init' };\n *  }\n * ```\n */\nexport declare interface OnInitEffects {\n  /**\n   * @description\n   * Action to be dispatched after the effect is registered.\n   */\n  ngrxOnInitEffects(): Action;\n}\n\nexport const onInitEffects: keyof OnInitEffects = 'ngrxOnInitEffects';\n\nexport function isOnInitEffects(instance: any): instance is OnInitEffects {\n  return isFunction(instance, onInitEffects);\n}\n\nfunction isFunction(instance: any, functionName: string) {\n  return (\n    instance &&\n    functionName in instance &&\n    typeof instance[functionName] === 'function'\n  );\n}\n", "import { ErrorHandler, Inject, Injectable } from '@angular/core';\nimport { Action } from '@ngrx/store';\nimport { Observable, Subject, merge } from 'rxjs';\nimport {\n  dematerialize,\n  exhaustMap,\n  filter,\n  groupBy,\n  map,\n  mergeMap,\n  take,\n} from 'rxjs/operators';\n\nimport {\n  reportInvalidActions,\n  EffectNotification,\n} from './effect_notification';\nimport { EffectsErrorHandler } from './effects_error_handler';\nimport { mergeEffects } from './effects_resolver';\nimport {\n  isOnIdentifyEffects,\n  isOnRunEffects,\n  isOnInitEffects,\n} from './lifecycle_hooks';\nimport { EFFECTS_ERROR_HANDLER } from './tokens';\nimport {\n  getSourceForInstance,\n  isClassInstance,\n  ObservableNotification,\n} from './utils';\n\n@Injectable({ providedIn: 'root' })\nexport class EffectSources extends Subject<any> {\n  constructor(\n    private errorHandler: ErrorHandler,\n    @Inject(EFFECTS_ERROR_HANDLER)\n    private effectsErrorHandler: EffectsErrorHandler\n  ) {\n    super();\n  }\n\n  addEffects(effectSourceInstance: any): void {\n    this.next(effectSourceInstance);\n  }\n\n  /**\n   * @internal\n   */\n  toActions(): Observable<Action> {\n    return this.pipe(\n      groupBy((effectsInstance) =>\n        isClassInstance(effectsInstance)\n          ? getSourceForInstance(effectsInstance)\n          : effectsInstance\n      ),\n      mergeMap((source$) => {\n        return source$.pipe(groupBy(effectsInstance));\n      }),\n      mergeMap((source$) => {\n        const effect$ = source$.pipe(\n          exhaustMap((sourceInstance) => {\n            return resolveEffectSource(\n              this.errorHandler,\n              this.effectsErrorHandler\n            )(sourceInstance);\n          }),\n          map((output) => {\n            reportInvalidActions(output, this.errorHandler);\n            return output.notification;\n          }),\n          filter(\n            (notification): notification is ObservableNotification<Action> =>\n              notification.kind === 'N' && notification.value != null\n          ),\n          dematerialize()\n        );\n\n        // start the stream with an INIT action\n        // do this only for the first Effect instance\n        const init$ = source$.pipe(\n          take(1),\n          filter(isOnInitEffects),\n          map((instance) => instance.ngrxOnInitEffects())\n        );\n\n        return merge(effect$, init$);\n      })\n    );\n  }\n}\n\nfunction effectsInstance(sourceInstance: any) {\n  if (isOnIdentifyEffects(sourceInstance)) {\n    return sourceInstance.ngrxOnIdentifyEffects();\n  }\n\n  return '';\n}\n\nfunction resolveEffectSource(\n  errorHandler: ErrorHandler,\n  effectsErrorHandler: EffectsErrorHandler\n): (sourceInstance: any) => Observable<EffectNotification> {\n  return (sourceInstance) => {\n    const mergedEffects$ = mergeEffects(\n      sourceInstance,\n      errorHandler,\n      effectsErrorHandler\n    );\n\n    if (isOnRunEffects(sourceInstance)) {\n      return sourceInstance.ngrxOnRunEffects(mergedEffects$);\n    }\n\n    return mergedEffects$;\n  };\n}\n", "import { Injectable, OnDestroy } from '@angular/core';\nimport { Store } from '@ngrx/store';\nimport { Subscription } from 'rxjs';\n\nimport { EffectSources } from './effect_sources';\n\n@Injectable({ providedIn: 'root' })\nexport class EffectsRunner implements OnDestroy {\n  private effectsSubscription: Subscription | null = null;\n\n  get isStarted(): boolean {\n    return !!this.effectsSubscription;\n  }\n\n  constructor(\n    private effectSources: EffectSources,\n    private store: Store<any>\n  ) {}\n\n  start() {\n    if (!this.effectsSubscription) {\n      this.effectsSubscription = this.effectSources\n        .toActions()\n        .subscribe(this.store);\n    }\n  }\n\n  ngOnDestroy() {\n    if (this.effectsSubscription) {\n      this.effectsSubscription.unsubscribe();\n      this.effectsSubscription = null;\n    }\n  }\n}\n", "import { NgModule, Inject, Optional } from '@angular/core';\nimport { Store, StoreRootModule, StoreFeatureModule } from '@ngrx/store';\nimport { EffectsRunner } from './effects_runner';\nimport { EffectSources } from './effect_sources';\nimport { _ROOT_EFFECTS_GUARD, _ROOT_EFFECTS_INSTANCES } from './tokens';\nimport { ROOT_EFFECTS_INIT } from './effects_actions';\n\n@NgModule({})\nexport class EffectsRootModule {\n  constructor(\n    private sources: EffectSources,\n    runner: EffectsRunner,\n    store: Store,\n    @Inject(_ROOT_EFFECTS_INSTANCES) rootEffectsInstances: unknown[],\n    @Optional() storeRootModule: StoreRootModule,\n    @Optional() storeFeatureModule: StoreFeatureModule,\n    @Optional()\n    @Inject(_ROOT_EFFECTS_GUARD)\n    guard: unknown\n  ) {\n    runner.start();\n\n    for (const effectsInstance of rootEffectsInstances) {\n      sources.addEffects(effectsInstance);\n    }\n\n    store.dispatch({ type: ROOT_EFFECTS_INIT });\n  }\n\n  addEffects(effectsInstance: unknown): void {\n    this.sources.addEffects(effectsInstance);\n  }\n}\n", "import { NgModule, Inject, Optional } from '@angular/core';\nimport { StoreRootModule, StoreFeatureModule } from '@ngrx/store';\nimport { EffectsRootModule } from './effects_root_module';\nimport { _FEATURE_EFFECTS_INSTANCE_GROUPS } from './tokens';\n\n@NgModule({})\nexport class EffectsFeatureModule {\n  constructor(\n    effectsRootModule: EffectsRootModule,\n    @Inject(_FEATURE_EFFECTS_INSTANCE_GROUPS)\n    effectsInstanceGroups: unknown[][],\n    @Optional() storeRootModule: StoreRootModule,\n    @Optional() storeFeatureModule: StoreFeatureModule\n  ) {\n    const effectsInstances = effectsInstanceGroups.flat();\n    for (const effectsInstance of effectsInstances) {\n      effectsRootModule.addEffects(effectsInstance);\n    }\n  }\n}\n", "import {\n  inject,\n  InjectionToken,\n  ModuleWithProviders,\n  NgModule,\n  Type,\n} from '@angular/core';\nimport { EffectsFeatureModule } from './effects_feature_module';\nimport { EffectsRootModule } from './effects_root_module';\nimport { EffectsRunner } from './effects_runner';\nimport {\n  _FEATURE_EFFECTS,\n  _ROOT_EFFECTS,\n  _ROOT_EFFECTS_GUARD,\n  _FEATURE_EFFECTS_INSTANCE_GROUPS,\n  _ROOT_EFFECTS_INSTANCES,\n  USER_PROVIDED_EFFECTS,\n} from './tokens';\nimport { FunctionalEffect } from './models';\nimport { getClasses, isToken } from './utils';\n\n@NgModule({})\nexport class EffectsModule {\n  static forFeature(\n    featureEffects: Array<Type<unknown> | Record<string, FunctionalEffect>>\n  ): ModuleWithProviders<EffectsFeatureModule>;\n  static forFeature(\n    ...featureEffects: Array<Type<unknown> | Record<string, FunctionalEffect>>\n  ): ModuleWithProviders<EffectsFeatureModule>;\n  static forFeature(\n    ...featureEffects:\n      | Array<Type<unknown> | Record<string, FunctionalEffect>>\n      | [Array<Type<unknown> | Record<string, FunctionalEffect>>]\n  ): ModuleWithProviders<EffectsFeatureModule> {\n    const effects = featureEffects.flat();\n    const effectsClasses = getClasses(effects);\n    return {\n      ngModule: EffectsFeatureModule,\n      providers: [\n        effectsClasses,\n        {\n          provide: _FEATURE_EFFECTS,\n          multi: true,\n          useValue: effects,\n        },\n        {\n          provide: USER_PROVIDED_EFFECTS,\n          multi: true,\n          useValue: [],\n        },\n        {\n          provide: _FEATURE_EFFECTS_INSTANCE_GROUPS,\n          multi: true,\n          useFactory: createEffectsInstances,\n          deps: [_FEATURE_EFFECTS, USER_PROVIDED_EFFECTS],\n        },\n      ],\n    };\n  }\n\n  static forRoot(\n    rootEffects: Array<Type<unknown> | Record<string, FunctionalEffect>>\n  ): ModuleWithProviders<EffectsRootModule>;\n  static forRoot(\n    ...rootEffects: Array<Type<unknown> | Record<string, FunctionalEffect>>\n  ): ModuleWithProviders<EffectsRootModule>;\n  static forRoot(\n    ...rootEffects:\n      | Array<Type<unknown> | Record<string, FunctionalEffect>>\n      | [Array<Type<unknown> | Record<string, FunctionalEffect>>]\n  ): ModuleWithProviders<EffectsRootModule> {\n    const effects = rootEffects.flat();\n    const effectsClasses = getClasses(effects);\n    return {\n      ngModule: EffectsRootModule,\n      providers: [\n        effectsClasses,\n        {\n          provide: _ROOT_EFFECTS,\n          useValue: [effects],\n        },\n        {\n          provide: _ROOT_EFFECTS_GUARD,\n          useFactory: _provideForRootGuard,\n        },\n        {\n          provide: USER_PROVIDED_EFFECTS,\n          multi: true,\n          useValue: [],\n        },\n        {\n          provide: _ROOT_EFFECTS_INSTANCES,\n          useFactory: createEffectsInstances,\n          deps: [_ROOT_EFFECTS, USER_PROVIDED_EFFECTS],\n        },\n      ],\n    };\n  }\n}\n\nfunction createEffectsInstances(\n  effectsGroups: Array<Type<unknown> | Record<string, FunctionalEffect>>[],\n  userProvidedEffectsGroups: Array<Type<unknown> | InjectionToken<unknown>>[]\n): unknown[] {\n  const effects: Array<\n    Type<unknown> | Record<string, FunctionalEffect> | InjectionToken<unknown>\n  > = [];\n\n  for (const effectsGroup of effectsGroups) {\n    effects.push(...effectsGroup);\n  }\n\n  for (const userProvidedEffectsGroup of userProvidedEffectsGroups) {\n    effects.push(...userProvidedEffectsGroup);\n  }\n\n  return effects.map((effectsTokenOrRecord) =>\n    isToken(effectsTokenOrRecord)\n      ? inject(effectsTokenOrRecord)\n      : effectsTokenOrRecord\n  );\n}\n\nfunction _provideForRootGuard(): unknown {\n  const runner = inject(EffectsRunner, { optional: true, skipSelf: true });\n  const rootEffects = inject(_ROOT_EFFECTS, { self: true });\n\n  // check whether any effects are actually passed\n  const hasEffects = !(rootEffects.length === 1 && rootEffects[0].length === 0);\n  if (hasEffects && runner) {\n    throw new TypeError(\n      `EffectsModule.forRoot() called twice. Feature modules should use EffectsModule.forFeature() instead.`\n    );\n  }\n  return 'guarded';\n}\n", "import { Action } from '@ngrx/store';\nimport { defer, merge, Observable, OperatorFunction, Subject } from 'rxjs';\nimport {\n  concatMap,\n  dematerialize,\n  filter,\n  finalize,\n  map,\n  materialize,\n} from 'rxjs/operators';\nimport { ObservableNotification } from './utils';\n\n/** Represents config with named parameters for act */\nexport interface ActConfig<\n  Input,\n  OutputAction extends Action,\n  ErrorAction extends Action,\n  CompleteAction extends Action,\n  UnsubscribeAction extends Action\n> {\n  // Project function that produces the output actions in success cases\n  project: (input: Input, index: number) => Observable<OutputAction>;\n  // Error handle function for project\n  // error that happened during project execution\n  // input value that project errored with\n  error: (error: any, input: Input) => ErrorAction;\n  // Optional complete action provider\n  // count is the number of actions project emitted before completion\n  // input value that project completed with\n  complete?: (count: number, input: Input) => CompleteAction;\n  // Optional flattening operator\n  operator?: <Input, OutputAction>(\n    project: (input: Input, index: number) => Observable<OutputAction>\n  ) => OperatorFunction<Input, OutputAction>;\n  // Optional unsubscribe action provider\n  // count is the number of actions project emitted before unsubscribing\n  // input value that was unsubscribed from\n  unsubscribe?: (count: number, input: Input) => UnsubscribeAction;\n}\n\n/**\n * @deprecated Use plain RxJS operators instead.\n * For more info see: https://github.com/ngrx/platform/issues/4072\n */\nexport function act<\n  Input,\n  OutputAction extends Action,\n  ErrorAction extends Action\n>(\n  project: (input: Input, index: number) => Observable<OutputAction>,\n  error: (error: any, input: Input) => ErrorAction\n): (source: Observable<Input>) => Observable<OutputAction | ErrorAction>;\n/**\n * @deprecated Use plain RxJS operators instead.\n * For more info see: https://github.com/ngrx/platform/issues/4072\n */\nexport function act<\n  Input,\n  OutputAction extends Action,\n  ErrorAction extends Action,\n  CompleteAction extends Action = never,\n  UnsubscribeAction extends Action = never\n>(\n  config: ActConfig<\n    Input,\n    OutputAction,\n    ErrorAction,\n    CompleteAction,\n    UnsubscribeAction\n  >\n): (\n  source: Observable<Input>\n) => Observable<\n  OutputAction | ErrorAction | CompleteAction | UnsubscribeAction\n>;\n/**\n * Wraps project fn with error handling making it safe to use in Effects.\n * Takes either a config with named properties that represent different possible\n * callbacks or project/error callbacks that are required.\n */\nexport function act<\n  Input,\n  OutputAction extends Action,\n  ErrorAction extends Action,\n  CompleteAction extends Action = never,\n  UnsubscribeAction extends Action = never\n>(\n  /** Allow to take either config object or project/error functions */\n  configOrProject:\n    | ActConfig<\n        Input,\n        OutputAction,\n        ErrorAction,\n        CompleteAction,\n        UnsubscribeAction\n      >\n    | ((input: Input, index: number) => Observable<OutputAction>),\n  errorFn?: (error: any, input: Input) => ErrorAction\n): (\n  source: Observable<Input>\n) => Observable<\n  OutputAction | ErrorAction | CompleteAction | UnsubscribeAction\n> {\n  const { project, error, complete, operator, unsubscribe } =\n    typeof configOrProject === 'function'\n      ? {\n          project: configOrProject,\n          // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n          error: errorFn!,\n          operator: concatMap,\n          complete: undefined,\n          unsubscribe: undefined,\n        }\n      : { ...configOrProject, operator: configOrProject.operator || concatMap };\n\n  type ResultAction =\n    | OutputAction\n    | ErrorAction\n    | CompleteAction\n    | UnsubscribeAction;\n  return (source) =>\n    defer((): Observable<ResultAction> => {\n      const subject = new Subject<UnsubscribeAction>();\n      return merge(\n        source.pipe(\n          operator((input, index) =>\n            defer(() => {\n              let completed = false;\n              let errored = false;\n              let projectedCount = 0;\n              return project(input, index).pipe(\n                materialize(),\n                map(\n                  (\n                    notification\n                  ):\n                    | ObservableNotification<\n                        ErrorAction | CompleteAction | OutputAction\n                      >\n                    | undefined => {\n                    switch (notification.kind) {\n                      case 'E':\n                        errored = true;\n                        return {\n                          kind: 'N',\n                          value: error(notification.error, input),\n                        };\n                      case 'C':\n                        completed = true;\n                        return complete\n                          ? {\n                              kind: 'N',\n                              value: complete(projectedCount, input),\n                            }\n                          : undefined;\n                      default:\n                        ++projectedCount;\n                        return notification as ObservableNotification<OutputAction>;\n                    }\n                  }\n                ),\n                filter((n): n is NonNullable<typeof n> => n != null),\n                dematerialize(),\n                finalize(() => {\n                  if (!completed && !errored && unsubscribe) {\n                    subject.next(unsubscribe(projectedCount, input));\n                  }\n                })\n              );\n            })\n          )\n        ),\n        subject\n      );\n    });\n}\n", "import {\n  ENVIRONMENT_INITIALIZER,\n  EnvironmentProviders,\n  inject,\n  makeEnvironmentProviders,\n  Type,\n} from '@angular/core';\nimport {\n  FEATURE_STATE_PROVIDER,\n  ROOT_STORE_PROVIDER,\n  Store,\n} from '@ngrx/store';\nimport { EffectsRunner } from './effects_runner';\nimport { EffectSources } from './effect_sources';\nimport { rootEffectsInit as effectsInit } from './effects_actions';\nimport { FunctionalEffect } from './models';\nimport { getClasses, isClass } from './utils';\n\n/**\n * Runs the provided effects.\n * Can be called at the root and feature levels.\n */\nexport function provideEffects(\n  effects: Array<Type<unknown> | Record<string, FunctionalEffect>>\n): EnvironmentProviders;\n/**\n * Runs the provided effects.\n * Can be called at the root and feature levels.\n */\nexport function provideEffects(\n  ...effects: Array<Type<unknown> | Record<string, FunctionalEffect>>\n): EnvironmentProviders;\n/**\n * @usageNotes\n *\n * ### Providing effects at the root level\n *\n * ```ts\n * bootstrapApplication(AppComponent, {\n *   providers: [provideEffects(RouterEffects)],\n * });\n * ```\n *\n * ### Providing effects at the feature level\n *\n * ```ts\n * const booksRoutes: Route[] = [\n *   {\n *     path: '',\n *     providers: [provideEffects(BooksApiEffects)],\n *     children: [\n *       { path: '', component: BookListComponent },\n *       { path: ':id', component: BookDetailsComponent },\n *     ],\n *   },\n * ];\n * ```\n */\nexport function provideEffects(\n  ...effects:\n    | Array<Type<unknown> | Record<string, FunctionalEffect>>\n    | [Array<Type<unknown> | Record<string, FunctionalEffect>>]\n): EnvironmentProviders {\n  const effectsClassesAndRecords = effects.flat();\n  const effectsClasses = getClasses(effectsClassesAndRecords);\n\n  return makeEnvironmentProviders([\n    effectsClasses,\n    {\n      provide: ENVIRONMENT_INITIALIZER,\n      multi: true,\n      useValue: () => {\n        inject(ROOT_STORE_PROVIDER);\n        inject(FEATURE_STATE_PROVIDER, { optional: true });\n\n        const effectsRunner = inject(EffectsRunner);\n        const effectSources = inject(EffectSources);\n        const shouldInitEffects = !effectsRunner.isStarted;\n\n        if (shouldInitEffects) {\n          effectsRunner.start();\n        }\n\n        for (const effectsClassOrRecord of effectsClassesAndRecords) {\n          const effectsInstance = isClass(effectsClassOrRecord)\n            ? inject(effectsClassOrRecord)\n            : effectsClassOrRecord;\n          effectSources.addEffects(effectsInstance);\n        }\n\n        if (shouldInitEffects) {\n          const store = inject(Store);\n          store.dispatch(effectsInit());\n        }\n      },\n    },\n  ]);\n}\n", "import * as operators from '@ngrx/operators';\n\nexport { createEffect } from './effect_creator';\nexport { EffectConfig } from './models';\nexport { getEffectsMetadata } from './effects_metadata';\nexport { mergeEffects } from './effects_resolver';\nexport {\n  EffectsErrorHandler,\n  defaultEffectsErrorHandler,\n} from './effects_error_handler';\nexport {\n  EffectsMetadata,\n  CreateEffectMetadata,\n  FunctionalEffect,\n} from './models';\nexport { Actions, ofType } from './actions';\nexport { EffectsModule } from './effects_module';\nexport { EffectSources } from './effect_sources';\nexport { ROOT_EFFECTS_INIT, rootEffectsInit } from './effects_actions';\nexport { EffectsRunner } from './effects_runner';\nexport { EffectNotification } from './effect_notification';\nexport { EffectsFeatureModule } from './effects_feature_module';\nexport { EffectsRootModule } from './effects_root_module';\nexport { EFFECTS_ERROR_HANDLER } from './tokens';\nexport { act } from './act';\nexport {\n  OnIdentifyEffects,\n  OnRunEffects,\n  OnInitEffects,\n} from './lifecycle_hooks';\nexport { USER_PROVIDED_EFFECTS } from './tokens';\nexport { provideEffects } from './provide_effects';\n\n/**\n * @deprecated Use `concatLatestFrom` from `@ngrx/operators` instead.\n */\nexport const concatLatestFrom = operators.concatLatestFrom;\n"],
  "mappings": "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",
  "names": ["InjectionToken", "Inject", "Injectable", "merge", "filter", "map", "effectsInstance", "Injectable", "Inject", "effectsInstance", "NgModule", "Inject", "Optional", "effectsInstance", "NgModule", "merge", "Subject", "dematerialize", "filter", "map", "materialize", "inject", "Store", "effectsInstance"]
}
