{"version":3,"file":"act.js","sourceRoot":"ng://@ngrx/effects/","sources":["src/act.ts"],"names":[],"mappings":";;;;;;;;;;;;;;;;AACA,OAAO,EACL,KAAK,EACL,KAAK,EACL,YAAY,EAGZ,OAAO,GACR,MAAM,MAAM,CAAC;AACd,OAAO,EACL,SAAS,EACT,aAAa,EACb,MAAM,EACN,QAAQ,EACR,GAAG,EACH,WAAW,GACZ,MAAM,gBAAgB,CAAC;;;;;;AAGxB,+BAyBC;;;IAjBC,4BAAmE;;IAInE,0BAAiD;;IAIjD,6BAA2D;;IAE3D,6BAE2C;;IAI3C,gCAAiE;;;;;;;;AAmCnE,MAAM,UAAU,GAAG;AAOjB,oEAAoE;AACpE,eAQ+D,EAC/D,OAAmD;IAM7C,IAAA;;;;;;;;sGASuE,EATrE,oBAAO,EAAE,gBAAK,EAAE,sBAAQ,EAAE,sBAAQ,EAAE,4BASiC;IAO7E;;;;IAAO,UAAA,MAAM;QACX,OAAA,KAAK;;;QACH;;gBACQ,OAAO,GAAG,IAAI,OAAO,EAAqB;YAChD,OAAO,KAAK,CACV,MAAM,CAAC,IAAI,CACT,QAAQ;;;;;YAAC,UAAC,KAAK,EAAE,KAAK;gBACpB,OAAA,KAAK;;;gBAAC;;wBACA,SAAS,GAAG,KAAK;;wBACjB,OAAO,GAAG,KAAK;;wBACf,cAAc,GAAG,CAAC;oBACtB,OAAO,OAAO,CAAC,KAAK,EAAE,KAAK,CAAC,CAAC,IAAI,CAC/B,WAAW,EAAE,EACb,GAAG;;;;oBACD,UAAC,YAAY;wBACX,QAAQ,YAAY,CAAC,IAAI,EAAE;4BACzB,KAAK,GAAG;gCACN,OAAO,GAAG,IAAI,CAAC;gCACf,OAAO,IAAI,YAAY,CAErB;gCADA,+BAA+B;gCAC/B,GAAG,EAAO,EACV,KAAK,CAAC,YAAY,CAAC,KAAK,EAAE,KAAK,CAAC,CACjC,CAAC;4BACJ,KAAK,GAAG;gCACN,SAAS,GAAG,IAAI,CAAC;gCACjB,OAAO,QAAQ;oCACb,CAAC,CAAC,IAAI,YAAY,CAEd;oCADA,+BAA+B;oCAC/B,GAAG,EAAO,EACV,QAAQ,CAAC,cAAc,EAAE,KAAK,CAAC,CAChC;oCACH,CAAC,CAAC,SAAS,CAAC;4BAChB;gCACE,EAAE,cAAc,CAAC;gCACjB,OAAO,YAAY,CAAC;yBACvB;oBACH,CAAC,EACF,EACD,MAAM;;;;oBAAC,UAAC,CAAC,IAAiC,OAAA,CAAC,IAAI,IAAI,EAAT,CAAS,EAAC,EACpD,aAAa,EAAE,EACf,QAAQ;;;oBAAC;wBACP,IAAI,CAAC,SAAS,IAAI,CAAC,OAAO,IAAI,WAAW,EAAE;4BACzC,OAAO,CAAC,IAAI,CAAC,WAAW,CAAC,cAAc,EAAE,KAAK,CAAC,CAAC,CAAC;yBAClD;oBACH,CAAC,EAAC,CACH,CAAC;gBACJ,CAAC,EAAC;YAvCF,CAuCE,EACH,CACF,EACD,OAAO,CACR,CAAC;QACJ,CAAC,EACF;IAnDD,CAmDC,EAAC;AACN,CAAC","sourcesContent":["import { Action } from '@ngrx/store';\nimport {\n  defer,\n  merge,\n  Notification,\n  Observable,\n  OperatorFunction,\n  Subject,\n} from 'rxjs';\nimport {\n  concatMap,\n  dematerialize,\n  filter,\n  finalize,\n  map,\n  materialize,\n} from 'rxjs/operators';\n\n/** Represents config with named paratemeters for act */\nexport interface ActConfig<\n  Input,\n  OutputAction extends Action,\n  ErrorAction extends Action,\n  CompleteAction extends Action,\n  UnsubscribeAction extends Action\n> {\n  // Project function that produces the output actions in success cases\n  project: (input: Input, index: number) => Observable<OutputAction>;\n  // Error handle function for project\n  // error that happened during project execution\n  // input value that project errored with\n  error: (error: any, input: Input) => ErrorAction;\n  // Optional complete action provider\n  // count is the number of actions project emitted before completion\n  // input value that project completed with\n  complete?: (count: number, input: Input) => CompleteAction;\n  // Optional flattening operator\n  operator?: <Input, OutputAction>(\n    project: (input: Input, index: number) => Observable<OutputAction>\n  ) => OperatorFunction<Input, OutputAction>;\n  // Optional unsubscribe action provider\n  // count is the number of actions project emitted before unsubscribing\n  // input value that was unsubscribed from\n  unsubscribe?: (count: number, input: Input) => UnsubscribeAction;\n}\n\n/**\n * Wraps project fn with error handling making it safe to use in Effects.\n * Takes either config with named properties that represent different possible\n * callbacks or project/error callbacks that are required.\n */\nexport function act<\n  Input,\n  OutputAction extends Action,\n  ErrorAction extends Action\n>(\n  project: (input: Input, index: number) => Observable<OutputAction>,\n  error: (error: any, input: Input) => ErrorAction\n): (source: Observable<Input>) => Observable<OutputAction | ErrorAction>;\nexport function act<\n  Input,\n  OutputAction extends Action,\n  ErrorAction extends Action,\n  CompleteAction extends Action = never,\n  UnsubscribeAction extends Action = never\n>(\n  config: ActConfig<\n    Input,\n    OutputAction,\n    ErrorAction,\n    CompleteAction,\n    UnsubscribeAction\n  >\n): (\n  source: Observable<Input>\n) => Observable<\n  OutputAction | ErrorAction | CompleteAction | UnsubscribeAction\n>;\nexport function act<\n  Input,\n  OutputAction extends Action,\n  ErrorAction extends Action,\n  CompleteAction extends Action = never,\n  UnsubscribeAction extends Action = never\n>(\n  /** Allow to take either config object or project/error functions */\n  configOrProject:\n    | ActConfig<\n        Input,\n        OutputAction,\n        ErrorAction,\n        CompleteAction,\n        UnsubscribeAction\n      >\n    | ((input: Input, index: number) => Observable<OutputAction>),\n  errorFn?: (error: any, input: Input) => ErrorAction\n): (\n  source: Observable<Input>\n) => Observable<\n  OutputAction | ErrorAction | CompleteAction | UnsubscribeAction\n> {\n  const { project, error, complete, operator, unsubscribe } =\n    typeof configOrProject === 'function'\n      ? {\n          project: configOrProject,\n          error: errorFn!,\n          operator: concatMap,\n          complete: undefined,\n          unsubscribe: undefined,\n        }\n      : { ...configOrProject, operator: configOrProject.operator || concatMap };\n\n  type ResultAction =\n    | OutputAction\n    | ErrorAction\n    | CompleteAction\n    | UnsubscribeAction;\n  return source =>\n    defer(\n      (): Observable<ResultAction> => {\n        const subject = new Subject<UnsubscribeAction>();\n        return merge(\n          source.pipe(\n            operator((input, index) =>\n              defer(() => {\n                let completed = false;\n                let errored = false;\n                let projectedCount = 0;\n                return project(input, index).pipe(\n                  materialize(),\n                  map(\n                    (notification): Notification<ResultAction> | undefined => {\n                      switch (notification.kind) {\n                        case 'E':\n                          errored = true;\n                          return new Notification(\n                            // TODO: remove any in RxJS 6.5\n                            'N' as any,\n                            error(notification.error, input)\n                          );\n                        case 'C':\n                          completed = true;\n                          return complete\n                            ? new Notification(\n                                // TODO: remove any in RxJS 6.5\n                                'N' as any,\n                                complete(projectedCount, input)\n                              )\n                            : undefined;\n                        default:\n                          ++projectedCount;\n                          return notification;\n                      }\n                    }\n                  ),\n                  filter((n): n is NonNullable<typeof n> => n != null),\n                  dematerialize(),\n                  finalize(() => {\n                    if (!completed && !errored && unsubscribe) {\n                      subject.next(unsubscribe(projectedCount, input));\n                    }\n                  })\n                );\n              })\n            )\n          ),\n          subject\n        );\n      }\n    );\n}\n"]}