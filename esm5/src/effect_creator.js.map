{"version":3,"file":"effect_creator.js","sourceRoot":"ng://@ngrx/effects/","sources":["src/effect_creator.ts"],"names":[],"mappings":";;;;;;;;;;;;;;;;AAEA,OAAO,EAGL,qBAAqB,EAErB,0BAA0B,GAC3B,MAAM,UAAU,CAAC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA6ClB,MAAM,UAAU,YAAY,CAM1B,MAA2D,EAC3D,MAAmB;;QAEb,MAAM,GAAG,MAAM,EAAE;;QACjB,KAAK,yBACN,qBAAqB,GACrB,MAAM,CACV;IACD,MAAM,CAAC,cAAc,CAAC,MAAM,EAAE,0BAA0B,EAAE;QACxD,KAAK,OAAA;KACN,CAAC,CAAC;IACH,OAAO,mBAAA,MAAM,EAAwC,CAAC;AACxD,CAAC;;;;;;AAED,MAAM,UAAU,uBAAuB,CAErC,QAAW;;QACL,aAAa,GAAG,mBAAA,MAAM,CAAC,mBAAmB,CAAC,QAAQ,CAAC,EAAkB;;QAEtE,QAAQ,GAAwB,aAAa;SAChD,MAAM;;;;IACL,UAAA,YAAY;QACV,OAAA,QAAQ,CAAC,YAAY,CAAC;YACtB,QAAQ,CAAC,YAAY,CAAC,CAAC,cAAc,CAAC,0BAA0B,CAAC;IADjE,CACiE,EACpE;SACA,GAAG;;;;IAAC,UAAA,YAAY;;YACT,QAAQ,GAAG,CAAC,mBAAA,QAAQ,CAAC,YAAY,CAAC,EAAO,CAAC,CAC9C,0BAA0B,CAC3B;QACD,kBACE,YAAY,cAAA,IACT,QAAQ,EACX;IACJ,CAAC,EAAC;IAEJ,OAAO,QAAQ,CAAC;AAClB,CAAC","sourcesContent":["import { Observable } from 'rxjs';\nimport { Action, ActionCreator } from '@ngrx/store';\nimport {\n  EffectMetadata,\n  EffectConfig,\n  DEFAULT_EFFECT_CONFIG,\n  CreateEffectMetadata,\n  CREATE_EFFECT_METADATA_KEY,\n} from './models';\n\ntype DispatchType<T> = T extends { dispatch: infer U } ? U : true;\ntype ObservableType<T, OriginalType> = T extends false ? OriginalType : Action;\ntype EffectResult<OT> = Observable<OT> | ((...args: any[]) => Observable<OT>);\ntype ConditionallyDisallowActionCreator<DT, Result> = DT extends false\n  ? unknown // If DT (DispatchType is false, then we don't enforce any return types)\n  : Result extends EffectResult<infer OT>\n    ? OT extends ActionCreator\n      ? 'ActionCreator cannot be dispatched. Did you forget to call the action creator function?'\n      : unknown\n    : unknown;\n\n/**\n * @description\n * Creates an effect from an `Observable` and an `EffectConfig`.\n *\n * @param source A function which returns an `Observable`.\n * @param config A `Partial<EffectConfig>` to configure the effect.  By default, `dispatch` is true and `useEffectsErrorHandler` is true.\n * @returns If `EffectConfig`#`dispatch` is true, returns `Observable<Action>`.  Else, returns `Observable<unknown>`.\n *\n * @usageNotes\n *\n * ** Mapping to a different action **\n * ```ts\n * effectName$ = createEffect(\n *   () => this.actions$.pipe(\n *     ofType(FeatureActions.actionOne),\n *     map(() => FeatureActions.actionTwo())\n *   )\n * );\n * ```\n *\n *  ** Non-dispatching effects **\n * ```ts\n * effectName$ = createEffect(\n *   () => this.actions$.pipe(\n *     ofType(FeatureActions.actionOne),\n *     tap(() => console.log('Action One Dispatched'))\n *   ),\n *   { dispatch: false }\n *   // FeatureActions.actionOne is not dispatched\n * );\n * ```\n */\nexport function createEffect<\n  C extends EffectConfig,\n  DT extends DispatchType<C>,\n  OT extends ObservableType<DT, OT>,\n  R extends EffectResult<OT>\n>(\n  source: () => R & ConditionallyDisallowActionCreator<DT, R>,\n  config?: Partial<C>\n): R & CreateEffectMetadata {\n  const effect = source();\n  const value: EffectConfig = {\n    ...DEFAULT_EFFECT_CONFIG,\n    ...config, // Overrides any defaults if values are provided\n  };\n  Object.defineProperty(effect, CREATE_EFFECT_METADATA_KEY, {\n    value,\n  });\n  return effect as typeof effect & CreateEffectMetadata;\n}\n\nexport function getCreateEffectMetadata<\n  T extends { [props in keyof T]: Object }\n>(instance: T): EffectMetadata<T>[] {\n  const propertyNames = Object.getOwnPropertyNames(instance) as Array<keyof T>;\n\n  const metadata: EffectMetadata<T>[] = propertyNames\n    .filter(\n      propertyName =>\n        instance[propertyName] &&\n        instance[propertyName].hasOwnProperty(CREATE_EFFECT_METADATA_KEY)\n    )\n    .map(propertyName => {\n      const metaData = (instance[propertyName] as any)[\n        CREATE_EFFECT_METADATA_KEY\n      ];\n      return {\n        propertyName,\n        ...metaData,\n      };\n    });\n\n  return metadata;\n}\n"]}