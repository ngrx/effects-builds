{"version":3,"sources":["ng://@ngrx/effects/src/models.ts","ng://@ngrx/effects/src/effect_creator.ts","ng://@ngrx/effects/src/utils.ts","ng://@ngrx/effects/src/effect_decorator.ts","ng://@ngrx/effects/src/effects_metadata.ts","ng://@ngrx/effects/src/effects_resolver.ts","ng://@ngrx/effects/src/effects_error_handler.ts","ng://@ngrx/effects/src/actions.ts","ng://@ngrx/effects/src/effect_notification.ts","ng://@ngrx/effects/src/lifecycle_hooks.ts","ng://@ngrx/effects/src/tokens.ts","ng://@ngrx/effects/src/effect_sources.ts","ng://@ngrx/effects/src/effects_runner.ts","ng://@ngrx/effects/src/effects_root_module.ts","ng://@ngrx/effects/src/effects_feature_module.ts","ng://@ngrx/effects/src/effects_module.ts","ng://@ngrx/effects/src/act.ts"],"names":["DEFAULT_EFFECT_CONFIG","dispatch","useEffectsErrorHandler","getCreateEffectMetadata","instance","Object","getOwnPropertyNames","filter","propertyName","hasOwnProperty","map","metaData","__assign","getSourceForInstance","getPrototypeOf","getEffectDecoratorMetadata","compose","getEffectMetadataEntries","hasMetadataEntries","sourceProto","constructor","getSourceMetadata","reduce","sources","source","concat","mergeEffects","sourceInstance","globalErrorHandler","effectsErrorHandler","sourceName","name","observables$","_a","observable$","effectAction$","pipe","ignoreElements","materialize","notification","effect","merge","apply","__spread","defaultEffectsErrorHandler","errorHandler","retryAttemptLeft","catchError","error","handleError","Actions","_this","_super","call","this","__extends","prototype","lift","operator","observable","Injectable","Observable","decorators","type","Inject","args","ScannedActionsSubject","reportInvalidActions","output","reporter","kind","action","value","isAction","Error","isMethod","String","JSON","stringify","isOnInitEffects","isFunction","functionName","_ROOT_EFFECTS_GUARD","InjectionToken","USER_PROVIDED_EFFECTS","_ROOT_EFFECTS","ROOT_EFFECTS","_FEATURE_EFFECTS","FEATURE_EFFECTS","EFFECTS_ERROR_HANDLER","EffectSources","addEffects","effectSourceInstance","next","toActions","groupBy","mergeMap","source$","effectsInstance","effect$","exhaustMap","mergedEffects$","ngrxOnRunEffects","dematerialize","init$","take","ngrxOnInitEffects","ErrorHandler","Subject","ngrxOnIdentifyEffects","EffectsRunner","effectSources","store","effectsSubscription","start","subscribe","ngOnDestroy","unsubscribe","Store","rootEffectsInit","createAction","EffectsRootModule","runner","rootEffects","storeRootModule","storeFeatureModule","guard","forEach","NgModule","StoreRootModule","Optional","StoreFeatureModule","EffectsFeatureModule","root","effectSourceGroups","group","EffectsModule","forFeature","featureEffects","ngModule","providers","provide","multi","useValue","useFactory","createEffects","deps","Injector","forRoot","_provideForRootGuard","SkipSelf","injector","effectGroups","userProvidedEffectGroups","mergedEffects","effectGroups_1","__values","effectGroups_1_1","done","effectGroup","push","__spread$1","userProvidedEffectGroups_1","userProvidedEffectGroups_1_1","userProvidedEffectGroup","effects","get","createEffectInstances","TypeError","config","target","metadata","defineProperty","addEffectMetadataEntry","__assign$1","configOrProject","errorFn","project","complete","defer","subject","input","index","completed","errored","projectedCount","Notification","undefined","n","finalize","acc","allowedTypes","_i","arguments","length","some","typeOrActionCreator"],"mappings":"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","sourcesContent":["/**\n * Configures an effect created by `createEffect`.\n */\nexport interface EffectConfig {\n  /**\n   * Determines if the action emitted by the effect is dispatched to the store.\n   * If false, effect does not need to return type `Observable<Action>`.\n   */\n  dispatch?: boolean;\n  /**\n   * Determines if the effect will be resubscribed to if an error occurs in the main actions stream.\n   */\n  useEffectsErrorHandler?: boolean;\n}\n\nexport const DEFAULT_EFFECT_CONFIG: Readonly<Required<EffectConfig>> = {\n  dispatch: true,\n  useEffectsErrorHandler: true,\n};\n\nexport const CREATE_EFFECT_METADATA_KEY = '__@ngrx/effects_create__';\n\nexport interface CreateEffectMetadata {\n  [CREATE_EFFECT_METADATA_KEY]: EffectConfig;\n}\n\nexport type EffectPropertyKey<T extends Object> = Exclude<\n  keyof T,\n  keyof Object\n>;\n\nexport interface EffectMetadata<T extends Object>\n  extends Required<EffectConfig> {\n  propertyName: EffectPropertyKey<T>;\n}\n\nexport type EffectsMetadata<T> = {\n  [key in EffectPropertyKey<T>]?: EffectConfig;\n};\n","import { Observable } from 'rxjs';\nimport { Action, ActionCreator } from '@ngrx/store';\nimport {\n  EffectMetadata,\n  EffectConfig,\n  DEFAULT_EFFECT_CONFIG,\n  CreateEffectMetadata,\n  CREATE_EFFECT_METADATA_KEY,\n} from './models';\n\ntype DispatchType<T> = T extends { dispatch: infer U } ? U : true;\ntype ObservableType<T, OriginalType> = T extends false ? OriginalType : Action;\ntype EffectResult<OT> = Observable<OT> | ((...args: any[]) => Observable<OT>);\ntype ConditionallyDisallowActionCreator<DT, Result> = DT extends false\n  ? unknown // If DT (DispatchType is false, then we don't enforce any return types)\n  : Result extends EffectResult<infer OT>\n  ? OT extends ActionCreator\n    ? 'ActionCreator cannot be dispatched. Did you forget to call the action creator function?'\n    : unknown\n  : unknown;\n\n/**\n * @description\n * Creates an effect from an `Observable` and an `EffectConfig`.\n *\n * @param source A function which returns an `Observable`.\n * @param config A `Partial<EffectConfig>` to configure the effect.  By default, `dispatch` is true and `useEffectsErrorHandler` is true.\n * @returns If `EffectConfig`#`dispatch` is true, returns `Observable<Action>`.  Else, returns `Observable<unknown>`.\n *\n * @usageNotes\n *\n * ** Mapping to a different action **\n * ```ts\n * effectName$ = createEffect(\n *   () => this.actions$.pipe(\n *     ofType(FeatureActions.actionOne),\n *     map(() => FeatureActions.actionTwo())\n *   )\n * );\n * ```\n *\n *  ** Non-dispatching effects **\n * ```ts\n * effectName$ = createEffect(\n *   () => this.actions$.pipe(\n *     ofType(FeatureActions.actionOne),\n *     tap(() => console.log('Action One Dispatched'))\n *   ),\n *   { dispatch: false }\n *   // FeatureActions.actionOne is not dispatched\n * );\n * ```\n */\nexport function createEffect<\n  C extends EffectConfig,\n  DT extends DispatchType<C>,\n  OT extends ObservableType<DT, OT>,\n  R extends EffectResult<OT>\n>(\n  source: () => R & ConditionallyDisallowActionCreator<DT, R>,\n  config?: Partial<C>\n): R & CreateEffectMetadata {\n  const effect = source();\n  const value: EffectConfig = {\n    ...DEFAULT_EFFECT_CONFIG,\n    ...config, // Overrides any defaults if values are provided\n  };\n  Object.defineProperty(effect, CREATE_EFFECT_METADATA_KEY, {\n    value,\n  });\n  return effect as typeof effect & CreateEffectMetadata;\n}\n\nexport function getCreateEffectMetadata<\n  T extends { [props in keyof T]: Object }\n>(instance: T): EffectMetadata<T>[] {\n  const propertyNames = Object.getOwnPropertyNames(instance) as Array<keyof T>;\n\n  const metadata: EffectMetadata<T>[] = propertyNames\n    .filter(\n      (propertyName) =>\n        instance[propertyName] &&\n        instance[propertyName].hasOwnProperty(CREATE_EFFECT_METADATA_KEY)\n    )\n    .map((propertyName) => {\n      const metaData = (instance[propertyName] as any)[\n        CREATE_EFFECT_METADATA_KEY\n      ];\n      return {\n        propertyName,\n        ...metaData,\n      };\n    });\n\n  return metadata;\n}\n","export function getSourceForInstance<T>(instance: T): T {\n  return Object.getPrototypeOf(instance);\n}\n","import { compose } from '@ngrx/store';\n\nimport {\n  DEFAULT_EFFECT_CONFIG,\n  EffectConfig,\n  EffectMetadata,\n  EffectPropertyKey,\n} from './models';\nimport { getSourceForInstance } from './utils';\n\nconst METADATA_KEY = '__@ngrx/effects__';\n\nexport function Effect(config: EffectConfig = {}) {\n  return function <T extends Object, K extends EffectPropertyKey<T>>(\n    target: T,\n    propertyName: K\n  ) {\n    const metadata: EffectMetadata<T> = {\n      ...DEFAULT_EFFECT_CONFIG,\n      ...config, // Overrides any defaults if values are provided\n      propertyName,\n    };\n    addEffectMetadataEntry<T>(target, metadata);\n  };\n}\n\nexport function getEffectDecoratorMetadata<T>(\n  instance: T\n): EffectMetadata<T>[] {\n  const effectsDecorators: EffectMetadata<T>[] = compose(\n    getEffectMetadataEntries,\n    getSourceForInstance\n  )(instance);\n\n  return effectsDecorators;\n}\n\n/**\n * Type guard to detemine whether METADATA_KEY is already present on the Class\n * constructor\n */\nfunction hasMetadataEntries<T extends Object>(\n  sourceProto: T\n): sourceProto is typeof sourceProto & {\n  constructor: typeof sourceProto.constructor & {\n    [METADATA_KEY]: EffectMetadata<T>[];\n  };\n} {\n  return sourceProto.constructor.hasOwnProperty(METADATA_KEY);\n}\n\n/** Add Effect Metadata to the Effect Class constructor under specific key */\nfunction addEffectMetadataEntry<T extends object>(\n  sourceProto: T,\n  metadata: EffectMetadata<T>\n) {\n  if (hasMetadataEntries(sourceProto)) {\n    sourceProto.constructor[METADATA_KEY].push(metadata);\n  } else {\n    Object.defineProperty(sourceProto.constructor, METADATA_KEY, {\n      value: [metadata],\n    });\n  }\n}\n\nfunction getEffectMetadataEntries<T extends object>(\n  sourceProto: T\n): EffectMetadata<T>[] {\n  return hasMetadataEntries(sourceProto)\n    ? sourceProto.constructor[METADATA_KEY]\n    : [];\n}\n","import { EffectMetadata, EffectsMetadata } from './models';\nimport { getCreateEffectMetadata } from './effect_creator';\nimport { getEffectDecoratorMetadata } from './effect_decorator';\n\nexport function getEffectsMetadata<T>(instance: T): EffectsMetadata<T> {\n  return getSourceMetadata(instance).reduce(\n    (\n      acc: EffectsMetadata<T>,\n      { propertyName, dispatch, useEffectsErrorHandler }\n    ) => {\n      acc[propertyName] = { dispatch, useEffectsErrorHandler };\n      return acc;\n    },\n    {}\n  );\n}\n\nexport function getSourceMetadata<T>(instance: T): EffectMetadata<T>[] {\n  const effects: Array<(instance: T) => EffectMetadata<T>[]> = [\n    getEffectDecoratorMetadata,\n    getCreateEffectMetadata,\n  ];\n\n  return effects.reduce<EffectMetadata<T>[]>(\n    (sources, source) => sources.concat(source(instance)),\n    []\n  );\n}\n","import { Action } from '@ngrx/store';\nimport { merge, Notification, Observable } from 'rxjs';\nimport { ignoreElements, map, materialize } from 'rxjs/operators';\n\nimport { EffectNotification } from './effect_notification';\nimport { getSourceMetadata } from './effects_metadata';\nimport { EffectsErrorHandler } from './effects_error_handler';\nimport { getSourceForInstance } from './utils';\nimport { ErrorHandler } from '@angular/core';\n\nexport function mergeEffects(\n  sourceInstance: any,\n  globalErrorHandler: ErrorHandler,\n  effectsErrorHandler: EffectsErrorHandler\n): Observable<EffectNotification> {\n  const sourceName = getSourceForInstance(sourceInstance).constructor.name;\n\n  const observables$: Observable<any>[] = getSourceMetadata(sourceInstance).map(\n    ({\n      propertyName,\n      dispatch,\n      useEffectsErrorHandler,\n    }): Observable<EffectNotification> => {\n      const observable$: Observable<any> =\n        typeof sourceInstance[propertyName] === 'function'\n          ? sourceInstance[propertyName]()\n          : sourceInstance[propertyName];\n\n      const effectAction$ = useEffectsErrorHandler\n        ? effectsErrorHandler(observable$, globalErrorHandler)\n        : observable$;\n\n      if (dispatch === false) {\n        return effectAction$.pipe(ignoreElements());\n      }\n\n      const materialized$ = effectAction$.pipe(materialize());\n\n      return materialized$.pipe(\n        map(\n          (notification: Notification<Action>): EffectNotification => ({\n            effect: sourceInstance[propertyName],\n            notification,\n            propertyName,\n            sourceName,\n            sourceInstance,\n          })\n        )\n      );\n    }\n  );\n\n  return merge(...observables$);\n}\n","import { ErrorHandler } from '@angular/core';\nimport { Action } from '@ngrx/store';\nimport { Observable } from 'rxjs';\nimport { catchError } from 'rxjs/operators';\n\nexport type EffectsErrorHandler = <T extends Action>(\n  observable$: Observable<T>,\n  errorHandler: ErrorHandler\n) => Observable<T>;\n\nconst MAX_NUMBER_OF_RETRY_ATTEMPTS = 10;\n\nexport function defaultEffectsErrorHandler<T extends Action>(\n  observable$: Observable<T>,\n  errorHandler: ErrorHandler,\n  retryAttemptLeft: number = MAX_NUMBER_OF_RETRY_ATTEMPTS\n): Observable<T> {\n  return observable$.pipe(\n    catchError((error) => {\n      if (errorHandler) errorHandler.handleError(error);\n      if (retryAttemptLeft <= 1) {\n        return observable$; // last attempt\n      }\n      // Return observable that produces this particular effect\n      return defaultEffectsErrorHandler(\n        observable$,\n        errorHandler,\n        retryAttemptLeft - 1\n      );\n    })\n  );\n}\n","import { Inject, Injectable } from '@angular/core';\nimport {\n  Action,\n  ActionCreator,\n  Creator,\n  ScannedActionsSubject,\n} from '@ngrx/store';\nimport { Observable, OperatorFunction, Operator } from 'rxjs';\nimport { filter } from 'rxjs/operators';\n\n@Injectable()\nexport class Actions<V = Action> extends Observable<V> {\n  constructor(@Inject(ScannedActionsSubject) source?: Observable<V>) {\n    super();\n\n    if (source) {\n      this.source = source;\n    }\n  }\n\n  lift<R>(operator: Operator<V, R>): Observable<R> {\n    const observable = new Actions<R>();\n    observable.source = this;\n    observable.operator = operator;\n    return observable;\n  }\n}\n\n// Module-private helper type\ntype ActionExtractor<\n  T extends string | AC,\n  AC extends ActionCreator<string, Creator>,\n  E\n> = T extends string ? E : ReturnType<Extract<T, AC>>;\n/**\n * 'ofType' filters an Observable of Actions into an observable of the actions\n * whose type strings are passed to it.\n *\n * For example, if `actions` has type `Actions<AdditionAction|SubstractionAction>`, and\n * the type of the `Addition` action is `add`, then\n * `actions.pipe(ofType('add'))` returns an `Observable<AdditionAction>`.\n *\n * Properly typing this function is hard and requires some advanced TS tricks\n * below.\n *\n * Type narrowing automatically works, as long as your `actions` object\n * starts with a `Actions<SomeUnionOfActions>` instead of generic `Actions`.\n *\n * For backwards compatibility, when one passes a single type argument\n * `ofType<T>('something')` the result is an `Observable<T>`. Note, that `T`\n * completely overrides any possible inference from 'something'.\n *\n * Unfortunately, for unknown 'actions: Actions' these types will produce\n * 'Observable<never>'. In such cases one has to manually set the generic type\n * like `actions.ofType<AdditionAction>('add')`.\n */\nexport function ofType<\n  AC extends ActionCreator<string, Creator>[],\n  U extends Action = Action,\n  V = ReturnType<AC[number]>\n>(...allowedTypes: AC): OperatorFunction<U, V>;\n\nexport function ofType<\n  E extends Extract<U, { type: T1 }>,\n  AC extends ActionCreator<string, Creator>,\n  T1 extends string | AC,\n  U extends Action = Action,\n  V = T1 extends string ? E : ReturnType<Extract<T1, AC>>\n>(t1: T1): OperatorFunction<U, V>;\nexport function ofType<\n  E extends Extract<U, { type: T1 | T2 }>,\n  AC extends ActionCreator<string, Creator>,\n  T1 extends string | AC,\n  T2 extends string | AC,\n  U extends Action = Action,\n  V = ActionExtractor<T1 | T2, AC, E>\n>(t1: T1, t2: T2): OperatorFunction<U, V>;\nexport function ofType<\n  E extends Extract<U, { type: T1 | T2 | T3 }>,\n  AC extends ActionCreator<string, Creator>,\n  T1 extends string | AC,\n  T2 extends string | AC,\n  T3 extends string | AC,\n  U extends Action = Action,\n  V = ActionExtractor<T1 | T2 | T3, AC, E>\n>(t1: T1, t2: T2, t3: T3): OperatorFunction<U, V>;\nexport function ofType<\n  E extends Extract<U, { type: T1 | T2 | T3 | T4 }>,\n  AC extends ActionCreator<string, Creator>,\n  T1 extends string | AC,\n  T2 extends string | AC,\n  T3 extends string | AC,\n  T4 extends string | AC,\n  U extends Action = Action,\n  V = ActionExtractor<T1 | T2 | T3 | T4, AC, E>\n>(t1: T1, t2: T2, t3: T3, t4: T4): OperatorFunction<U, V>;\nexport function ofType<\n  E extends Extract<U, { type: T1 | T2 | T3 | T4 | T5 }>,\n  AC extends ActionCreator<string, Creator>,\n  T1 extends string | AC,\n  T2 extends string | AC,\n  T3 extends string | AC,\n  T4 extends string | AC,\n  T5 extends string | AC,\n  U extends Action = Action,\n  V = ActionExtractor<T1 | T2 | T3 | T4 | T5, AC, E>\n>(t1: T1, t2: T2, t3: T3, t4: T4, t5: T5): OperatorFunction<U, V>;\n/**\n * Fallback for more than 5 arguments.\n * There is no inference, so the return type is the same as the input -\n * Observable<Action>.\n *\n * We provide a type parameter, even though TS will not infer it from the\n * arguments, to preserve backwards compatibility with old versions of ngrx.\n */\nexport function ofType<V extends Action>(\n  ...allowedTypes: Array<string | ActionCreator<string, Creator>>\n): OperatorFunction<Action, V>;\nexport function ofType(\n  ...allowedTypes: Array<string | ActionCreator<string, Creator>>\n): OperatorFunction<Action, Action> {\n  return filter((action: Action) =>\n    allowedTypes.some((typeOrActionCreator) => {\n      if (typeof typeOrActionCreator === 'string') {\n        // Comparing the string to type\n        return typeOrActionCreator === action.type;\n      }\n\n      // We are filtering by ActionCreator\n      return typeOrActionCreator.type === action.type;\n    })\n  );\n}\n","import { ErrorHandler } from '@angular/core';\nimport { Action } from '@ngrx/store';\nimport { Notification, Observable } from 'rxjs';\n\nexport interface EffectNotification {\n  effect: Observable<any> | (() => Observable<any>);\n  propertyName: PropertyKey;\n  sourceName: string;\n  sourceInstance: any;\n  notification: Notification<Action | null | undefined>;\n}\n\nexport function reportInvalidActions(\n  output: EffectNotification,\n  reporter: ErrorHandler\n) {\n  if (output.notification.kind === 'N') {\n    const action = output.notification.value;\n    const isInvalidAction = !isAction(action);\n\n    if (isInvalidAction) {\n      reporter.handleError(\n        new Error(\n          `Effect ${getEffectName(\n            output\n          )} dispatched an invalid action: ${stringify(action)}`\n        )\n      );\n    }\n  }\n}\n\nfunction isAction(action: any): action is Action {\n  return (\n    typeof action !== 'function' &&\n    action &&\n    action.type &&\n    typeof action.type === 'string'\n  );\n}\n\nfunction getEffectName({\n  propertyName,\n  sourceInstance,\n  sourceName,\n}: EffectNotification) {\n  const isMethod = typeof sourceInstance[propertyName] === 'function';\n\n  return `\"${sourceName}.${String(propertyName)}${isMethod ? '()' : ''}\"`;\n}\n\nfunction stringify(action: Action | null | undefined) {\n  try {\n    return JSON.stringify(action);\n  } catch {\n    return action;\n  }\n}\n","import { Observable } from 'rxjs';\nimport { EffectNotification } from '.';\nimport { Action } from '@ngrx/store';\n\n/**\n * @description\n * Interface to set an identifier for effect instances.\n *\n * By default, each Effects class is registered\n * once regardless of how many times the Effect class\n * is loaded. By implementing this interface, you define\n * a unique identifier to register an Effects class instance\n * multiple times.\n *\n * @usageNotes\n *\n * ### Set an identifier for an Effects class\n *\n * ```ts\n * class EffectWithIdentifier implements OnIdentifyEffects {\n *  constructor(private effectIdentifier: string) {}\n *\n *  ngrxOnIdentifyEffects() {\n *    return this.effectIdentifier;\n *  }\n *\n * ```\n */\nexport declare interface OnIdentifyEffects {\n  /**\n   * @description\n   * String identifier to differentiate effect instances.\n   */\n  ngrxOnIdentifyEffects(): string;\n}\n\nexport const onIdentifyEffectsKey: keyof OnIdentifyEffects =\n  'ngrxOnIdentifyEffects';\n\nexport function isOnIdentifyEffects(\n  instance: any\n): instance is OnIdentifyEffects {\n  return isFunction(instance, onIdentifyEffectsKey);\n}\n\n/**\n * @description\n * Interface to control the lifecycle of effects.\n *\n * By default, effects are merged and subscribed to the store. Implement the OnRunEffects interface to control the lifecycle of the resolved effects.\n *\n * @usageNotes\n *\n * ### Implement the OnRunEffects interface on an Effects class\n *\n * ```ts\n * export class UserEffects implements OnRunEffects {\n *   constructor(private actions$: Actions) {}\n *\n *   ngrxOnRunEffects(resolvedEffects$: Observable<EffectNotification>) {\n *     return this.actions$.pipe(\n *       ofType('LOGGED_IN'),\n *       exhaustMap(() =>\n *         resolvedEffects$.pipe(\n *           takeUntil(this.actions$.pipe(ofType('LOGGED_OUT')))\n *         )\n *       )\n *     );\n *   }\n * }\n * ```\n */\nexport declare interface OnRunEffects {\n  /**\n   * @description\n   * Method to control the lifecycle of effects.\n   */\n  ngrxOnRunEffects(\n    resolvedEffects$: Observable<EffectNotification>\n  ): Observable<EffectNotification>;\n}\n\nexport const onRunEffectsKey: keyof OnRunEffects = 'ngrxOnRunEffects';\n\nexport function isOnRunEffects(instance: any): instance is OnRunEffects {\n  return isFunction(instance, onRunEffectsKey);\n}\n\n/**\n * @description\n * Interface to dispatch an action after effect registration.\n *\n * Implement this interface to dispatch a custom action after\n * the effect has been added. You can listen to this action\n * in the rest of the application to execute something after\n * the effect is registered.\n *\n * @usageNotes\n *\n * ### Set an identifier for an Effects class\n *\n * ```ts\n * class EffectWithInitAction implements OnInitEffects {\n *  ngrxOnInitEffects() {\n *    return { type: '[EffectWithInitAction] Init' };\n *  }\n * ```\n */\nexport declare interface OnInitEffects {\n  /**\n   * @description\n   * Action to be dispatched after the effect is registered.\n   */\n  ngrxOnInitEffects(): Action;\n}\n\nexport const onInitEffects: keyof OnInitEffects = 'ngrxOnInitEffects';\n\nexport function isOnInitEffects(instance: any): instance is OnInitEffects {\n  return isFunction(instance, onInitEffects);\n}\n\nfunction isFunction(instance: any, functionName: string) {\n  return (\n    instance &&\n    functionName in instance &&\n    typeof instance[functionName] === 'function'\n  );\n}\n","import { InjectionToken, Type } from '@angular/core';\nimport { EffectsErrorHandler } from './effects_error_handler';\n\nexport const _ROOT_EFFECTS_GUARD = new InjectionToken<void>(\n  '@ngrx/effects Internal Root Guard'\n);\nexport const IMMEDIATE_EFFECTS = new InjectionToken<any[]>(\n  'ngrx/effects: Immediate Effects'\n);\nexport const USER_PROVIDED_EFFECTS = new InjectionToken<Type<any>[][]>(\n  'ngrx/effects: User Provided Effects'\n);\nexport const _ROOT_EFFECTS = new InjectionToken<Type<any>[]>(\n  'ngrx/effects: Internal Root Effects'\n);\nexport const ROOT_EFFECTS = new InjectionToken<Type<any>[]>(\n  'ngrx/effects: Root Effects'\n);\nexport const _FEATURE_EFFECTS = new InjectionToken<Type<any>[]>(\n  'ngrx/effects: Internal Feature Effects'\n);\nexport const FEATURE_EFFECTS = new InjectionToken<any[][]>(\n  'ngrx/effects: Feature Effects'\n);\nexport const EFFECTS_ERROR_HANDLER = new InjectionToken<EffectsErrorHandler>(\n  'ngrx/effects: Effects Error Handler'\n);\n","import { ErrorHandler, Inject, Injectable } from '@angular/core';\nimport { Action } from '@ngrx/store';\nimport { Notification, Observable, Subject, merge } from 'rxjs';\nimport {\n  dematerialize,\n  exhaustMap,\n  filter,\n  groupBy,\n  map,\n  mergeMap,\n  take,\n} from 'rxjs/operators';\n\nimport {\n  reportInvalidActions,\n  EffectNotification,\n} from './effect_notification';\nimport { EffectsErrorHandler } from './effects_error_handler';\nimport { mergeEffects } from './effects_resolver';\nimport {\n  onIdentifyEffectsKey,\n  onRunEffectsKey,\n  OnRunEffects,\n  onInitEffects,\n  isOnIdentifyEffects,\n  isOnRunEffects,\n  isOnInitEffects,\n} from './lifecycle_hooks';\nimport { EFFECTS_ERROR_HANDLER } from './tokens';\nimport { getSourceForInstance } from './utils';\n\n@Injectable()\nexport class EffectSources extends Subject<any> {\n  constructor(\n    private errorHandler: ErrorHandler,\n    @Inject(EFFECTS_ERROR_HANDLER)\n    private effectsErrorHandler: EffectsErrorHandler\n  ) {\n    super();\n  }\n\n  addEffects(effectSourceInstance: any): void {\n    this.next(effectSourceInstance);\n  }\n\n  /**\n   * @internal\n   */\n  toActions(): Observable<Action> {\n    return this.pipe(\n      groupBy(getSourceForInstance),\n      mergeMap((source$) => {\n        return source$.pipe(groupBy(effectsInstance));\n      }),\n      mergeMap((source$) => {\n        const effect$ = source$.pipe(\n          exhaustMap((sourceInstance) => {\n            return resolveEffectSource(\n              this.errorHandler,\n              this.effectsErrorHandler\n            )(sourceInstance);\n          }),\n          map((output) => {\n            reportInvalidActions(output, this.errorHandler);\n            return output.notification;\n          }),\n          filter(\n            (notification): notification is Notification<Action> =>\n              notification.kind === 'N'\n          ),\n          dematerialize()\n        );\n\n        // start the stream with an INIT action\n        // do this only for the first Effect instance\n        const init$ = source$.pipe(\n          take(1),\n          filter(isOnInitEffects),\n          map((instance) => instance.ngrxOnInitEffects())\n        );\n\n        return merge(effect$, init$);\n      })\n    );\n  }\n}\n\nfunction effectsInstance(sourceInstance: any) {\n  if (isOnIdentifyEffects(sourceInstance)) {\n    return sourceInstance.ngrxOnIdentifyEffects();\n  }\n\n  return '';\n}\n\nfunction resolveEffectSource(\n  errorHandler: ErrorHandler,\n  effectsErrorHandler: EffectsErrorHandler\n): (sourceInstance: any) => Observable<EffectNotification> {\n  return (sourceInstance) => {\n    const mergedEffects$ = mergeEffects(\n      sourceInstance,\n      errorHandler,\n      effectsErrorHandler\n    );\n\n    if (isOnRunEffects(sourceInstance)) {\n      return sourceInstance.ngrxOnRunEffects(mergedEffects$);\n    }\n\n    return mergedEffects$;\n  };\n}\n","import { Injectable, OnDestroy } from '@angular/core';\nimport { Store } from '@ngrx/store';\nimport { Subscription } from 'rxjs';\n\nimport { EffectSources } from './effect_sources';\n\n@Injectable()\nexport class EffectsRunner implements OnDestroy {\n  private effectsSubscription: Subscription | null = null;\n\n  constructor(\n    private effectSources: EffectSources,\n    private store: Store<any>\n  ) {}\n\n  start() {\n    if (!this.effectsSubscription) {\n      this.effectsSubscription = this.effectSources\n        .toActions()\n        .subscribe(this.store);\n    }\n  }\n\n  ngOnDestroy() {\n    if (this.effectsSubscription) {\n      this.effectsSubscription.unsubscribe();\n      this.effectsSubscription = null;\n    }\n  }\n}\n","import { NgModule, Inject, Optional } from '@angular/core';\nimport {\n  createAction,\n  StoreModule,\n  Store,\n  StoreRootModule,\n  StoreFeatureModule,\n} from '@ngrx/store';\nimport { EffectsRunner } from './effects_runner';\nimport { EffectSources } from './effect_sources';\nimport { ROOT_EFFECTS, _ROOT_EFFECTS_GUARD } from './tokens';\n\nexport const ROOT_EFFECTS_INIT = '@ngrx/effects/init';\nexport const rootEffectsInit = createAction(ROOT_EFFECTS_INIT);\n\n@NgModule({})\nexport class EffectsRootModule {\n  constructor(\n    private sources: EffectSources,\n    runner: EffectsRunner,\n    store: Store<any>,\n    @Inject(ROOT_EFFECTS) rootEffects: any[],\n    @Optional() storeRootModule: StoreRootModule,\n    @Optional() storeFeatureModule: StoreFeatureModule,\n    @Optional()\n    @Inject(_ROOT_EFFECTS_GUARD)\n    guard: any\n  ) {\n    runner.start();\n\n    rootEffects.forEach((effectSourceInstance) =>\n      sources.addEffects(effectSourceInstance)\n    );\n\n    store.dispatch({ type: ROOT_EFFECTS_INIT });\n  }\n\n  addEffects(effectSourceInstance: any) {\n    this.sources.addEffects(effectSourceInstance);\n  }\n}\n","import { NgModule, Inject, Optional } from '@angular/core';\nimport { StoreRootModule, StoreFeatureModule } from '@ngrx/store';\nimport { EffectsRootModule } from './effects_root_module';\nimport { FEATURE_EFFECTS } from './tokens';\n\n@NgModule({})\nexport class EffectsFeatureModule {\n  constructor(\n    root: EffectsRootModule,\n    @Inject(FEATURE_EFFECTS) effectSourceGroups: any[][],\n    @Optional() storeRootModule: StoreRootModule,\n    @Optional() storeFeatureModule: StoreFeatureModule\n  ) {\n    effectSourceGroups.forEach((group) =>\n      group.forEach((effectSourceInstance) =>\n        root.addEffects(effectSourceInstance)\n      )\n    );\n  }\n}\n","import {\n  Injector,\n  ModuleWithProviders,\n  NgModule,\n  Optional,\n  SkipSelf,\n  Type,\n} from '@angular/core';\nimport { Actions } from './actions';\nimport { EffectSources } from './effect_sources';\nimport { EffectsFeatureModule } from './effects_feature_module';\nimport { defaultEffectsErrorHandler } from './effects_error_handler';\nimport { EffectsRootModule } from './effects_root_module';\nimport { EffectsRunner } from './effects_runner';\nimport {\n  _FEATURE_EFFECTS,\n  _ROOT_EFFECTS,\n  _ROOT_EFFECTS_GUARD,\n  EFFECTS_ERROR_HANDLER,\n  FEATURE_EFFECTS,\n  ROOT_EFFECTS,\n  USER_PROVIDED_EFFECTS,\n} from './tokens';\n\n@NgModule({})\nexport class EffectsModule {\n  static forFeature(\n    featureEffects: Type<any>[] = []\n  ): ModuleWithProviders<EffectsFeatureModule> {\n    return {\n      ngModule: EffectsFeatureModule,\n      providers: [\n        featureEffects,\n        {\n          provide: _FEATURE_EFFECTS,\n          multi: true,\n          useValue: featureEffects,\n        },\n        {\n          provide: USER_PROVIDED_EFFECTS,\n          multi: true,\n          useValue: [],\n        },\n        {\n          provide: FEATURE_EFFECTS,\n          multi: true,\n          useFactory: createEffects,\n          deps: [Injector, _FEATURE_EFFECTS, USER_PROVIDED_EFFECTS],\n        },\n      ],\n    };\n  }\n\n  static forRoot(\n    rootEffects: Type<any>[] = []\n  ): ModuleWithProviders<EffectsRootModule> {\n    return {\n      ngModule: EffectsRootModule,\n      providers: [\n        {\n          provide: _ROOT_EFFECTS_GUARD,\n          useFactory: _provideForRootGuard,\n          deps: [[EffectsRunner, new Optional(), new SkipSelf()]],\n        },\n        {\n          provide: EFFECTS_ERROR_HANDLER,\n          useValue: defaultEffectsErrorHandler,\n        },\n        EffectsRunner,\n        EffectSources,\n        Actions,\n        rootEffects,\n        {\n          provide: _ROOT_EFFECTS,\n          useValue: [rootEffects],\n        },\n        {\n          provide: USER_PROVIDED_EFFECTS,\n          multi: true,\n          useValue: [],\n        },\n        {\n          provide: ROOT_EFFECTS,\n          useFactory: createEffects,\n          deps: [Injector, _ROOT_EFFECTS, USER_PROVIDED_EFFECTS],\n        },\n      ],\n    };\n  }\n}\n\nexport function createEffects(\n  injector: Injector,\n  effectGroups: Type<any>[][],\n  userProvidedEffectGroups: Type<any>[][]\n): any[] {\n  const mergedEffects: Type<any>[] = [];\n\n  for (let effectGroup of effectGroups) {\n    mergedEffects.push(...effectGroup);\n  }\n\n  for (let userProvidedEffectGroup of userProvidedEffectGroups) {\n    mergedEffects.push(...userProvidedEffectGroup);\n  }\n\n  return createEffectInstances(injector, mergedEffects);\n}\n\nexport function createEffectInstances(\n  injector: Injector,\n  effects: Type<any>[]\n): any[] {\n  return effects.map((effect) => injector.get(effect));\n}\n\nexport function _provideForRootGuard(runner: EffectsRunner): any {\n  if (runner) {\n    throw new TypeError(\n      `EffectsModule.forRoot() called twice. Feature modules should use EffectsModule.forFeature() instead.`\n    );\n  }\n  return 'guarded';\n}\n","import { Action } from '@ngrx/store';\nimport {\n  defer,\n  merge,\n  Notification,\n  Observable,\n  OperatorFunction,\n  Subject,\n} from 'rxjs';\nimport {\n  concatMap,\n  dematerialize,\n  filter,\n  finalize,\n  map,\n  materialize,\n} from 'rxjs/operators';\n\n/** Represents config with named paratemeters for act */\nexport interface ActConfig<\n  Input,\n  OutputAction extends Action,\n  ErrorAction extends Action,\n  CompleteAction extends Action,\n  UnsubscribeAction extends Action\n> {\n  // Project function that produces the output actions in success cases\n  project: (input: Input, index: number) => Observable<OutputAction>;\n  // Error handle function for project\n  // error that happened during project execution\n  // input value that project errored with\n  error: (error: any, input: Input) => ErrorAction;\n  // Optional complete action provider\n  // count is the number of actions project emitted before completion\n  // input value that project completed with\n  complete?: (count: number, input: Input) => CompleteAction;\n  // Optional flattening operator\n  operator?: <Input, OutputAction>(\n    project: (input: Input, index: number) => Observable<OutputAction>\n  ) => OperatorFunction<Input, OutputAction>;\n  // Optional unsubscribe action provider\n  // count is the number of actions project emitted before unsubscribing\n  // input value that was unsubscribed from\n  unsubscribe?: (count: number, input: Input) => UnsubscribeAction;\n}\n\n/**\n * Wraps project fn with error handling making it safe to use in Effects.\n * Takes either config with named properties that represent different possible\n * callbacks or project/error callbacks that are required.\n */\nexport function act<\n  Input,\n  OutputAction extends Action,\n  ErrorAction extends Action\n>(\n  project: (input: Input, index: number) => Observable<OutputAction>,\n  error: (error: any, input: Input) => ErrorAction\n): (source: Observable<Input>) => Observable<OutputAction | ErrorAction>;\nexport function act<\n  Input,\n  OutputAction extends Action,\n  ErrorAction extends Action,\n  CompleteAction extends Action = never,\n  UnsubscribeAction extends Action = never\n>(\n  config: ActConfig<\n    Input,\n    OutputAction,\n    ErrorAction,\n    CompleteAction,\n    UnsubscribeAction\n  >\n): (\n  source: Observable<Input>\n) => Observable<\n  OutputAction | ErrorAction | CompleteAction | UnsubscribeAction\n>;\nexport function act<\n  Input,\n  OutputAction extends Action,\n  ErrorAction extends Action,\n  CompleteAction extends Action = never,\n  UnsubscribeAction extends Action = never\n>(\n  /** Allow to take either config object or project/error functions */\n  configOrProject:\n    | ActConfig<\n        Input,\n        OutputAction,\n        ErrorAction,\n        CompleteAction,\n        UnsubscribeAction\n      >\n    | ((input: Input, index: number) => Observable<OutputAction>),\n  errorFn?: (error: any, input: Input) => ErrorAction\n): (\n  source: Observable<Input>\n) => Observable<\n  OutputAction | ErrorAction | CompleteAction | UnsubscribeAction\n> {\n  const { project, error, complete, operator, unsubscribe } =\n    typeof configOrProject === 'function'\n      ? {\n          project: configOrProject,\n          error: errorFn!,\n          operator: concatMap,\n          complete: undefined,\n          unsubscribe: undefined,\n        }\n      : { ...configOrProject, operator: configOrProject.operator || concatMap };\n\n  type ResultAction =\n    | OutputAction\n    | ErrorAction\n    | CompleteAction\n    | UnsubscribeAction;\n  return (source) =>\n    defer(\n      (): Observable<ResultAction> => {\n        const subject = new Subject<UnsubscribeAction>();\n        return merge(\n          source.pipe(\n            operator((input, index) =>\n              defer(() => {\n                let completed = false;\n                let errored = false;\n                let projectedCount = 0;\n                return project(input, index).pipe(\n                  materialize(),\n                  map((notification):\n                    | Notification<ResultAction>\n                    | undefined => {\n                    switch (notification.kind) {\n                      case 'E':\n                        errored = true;\n                        return new Notification(\n                          // TODO: remove any in RxJS 6.5\n                          'N' as any,\n                          error(notification.error, input)\n                        );\n                      case 'C':\n                        completed = true;\n                        return complete\n                          ? new Notification(\n                              // TODO: remove any in RxJS 6.5\n                              'N' as any,\n                              complete(projectedCount, input)\n                            )\n                          : undefined;\n                      default:\n                        ++projectedCount;\n                        return notification;\n                    }\n                  }),\n                  filter((n): n is NonNullable<typeof n> => n != null),\n                  dematerialize(),\n                  finalize(() => {\n                    if (!completed && !errored && unsubscribe) {\n                      subject.next(unsubscribe(projectedCount, input));\n                    }\n                  })\n                );\n              })\n            )\n          ),\n          subject\n        );\n      }\n    );\n}\n"]}